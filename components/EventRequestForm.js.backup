import React, { useState, useEffect, useCallback } from 'react';
import { 
  View, Text, StyleSheet, TextInput, TouchableOpacity, 
  ScrollView, Modal, Alert, ActivityIndicator
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { useAuth } from '../context/AuthContext';
import axios from 'axios';
import { BACKEND_URL } from '../constants/config';

const EventRequestForm = ({ visible, onClose, spaceId, spaceName, managerId }) => {
  const { user, token } = useAuth();
  const [loading, setLoading] = useState(false);
  const [availableSlots, setAvailableSlots] = useState([]);
  const [blockedSlots, setBlockedSlots] = useState([]);
  const [loadingSlots, setLoadingSlots] = useState(true);
  const [filteredTimeSlots, setFilteredTimeSlots] = useState([]);
  const [confirmModalVisible, setConfirmModalVisible] = useState(false);
  
  // Funci√≥n auxiliar para obtener el nombre del d√≠a a partir de su ID
  const getDayName = (dayId) => {
    const days = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
    return days[dayId] || 'Desconocido';
  };
  
  // Funci√≥n para convertir el valor de la categor√≠a a un texto m√°s legible
  const getCategoryLabel = (category) => {
    const categoryLabels = {
      'musica': 'M√∫sica',
      'danza': 'Danza',
      'teatro': 'Teatro',
      'artes_visuales': 'Artes Visuales',
      'literatura': 'Literatura',
      'cine': 'Cine',
      'fotografia': 'Fotograf√≠a',
      'otro': 'Otro'
    };
    return categoryLabels[category] || category.charAt(0).toUpperCase() + category.slice(1);
  };
  
  // Funci√≥n para calcular la duraci√≥n del evento
  const calculateEventDuration = (startTime, endTime) => {
    const startHour = startTime.getHours();
    const startMinutes = startTime.getMinutes();
    const endHour = endTime.getHours();
    const endMinutes = endTime.getMinutes();
    
    const durationHours = endHour - startHour;
    const durationMinutes = endMinutes - startMinutes;
    
    return `${durationHours} horas y ${durationMinutes} minutos`;
  };
  
  // Estados para el formulario
  const [eventName, setEventName] = useState('');
  const [eventDescription, setEventDescription] = useState('');
  const [eventDate, setEventDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [selectedTimeSlots, setSelectedTimeSlots] = useState([]);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null); // Mantener para compatibilidad
  const [expectedAttendees, setExpectedAttendees] = useState('');
  const [eventType, setEventType] = useState('');
  const [eventCategory, setEventCategory] = useState('otro');
  const [customCategory, setCustomCategory] = useState('');
  const [additionalRequirements, setAdditionalRequirements] = useState('');
  
  // Funci√≥n para manejar la selecci√≥n de m√∫ltiples slots de tiempo
  const handleTimeSlotSelection = (slot) => {
    // Si no hay slots seleccionados, simplemente a√±adir el slot
    if (selectedTimeSlots.length === 0) {
      setSelectedTimeSlots([slot]);
      setSelectedTimeSlot(slot); // Mantener para compatibilidad
      return;
    }
    
    // Ordenar los slots seleccionados por hora
    const sortedSlots = [...selectedTimeSlots].sort((a, b) => {
      return a.hour - b.hour;
    });
    
    // Verificar si el slot seleccionado es consecutivo con los ya seleccionados
    const firstSlot = sortedSlots[0];
    const lastSlot = sortedSlots[sortedSlots.length - 1];
    
    // Si el slot es una hora antes del primer slot seleccionado
    if (slot.hour === firstSlot.hour - 1) {
      const newSlots = [slot, ...sortedSlots];
      setSelectedTimeSlots(newSlots);
      setSelectedTimeSlot(newSlots[0]); // Actualizar para compatibilidad
      return;
    }
    
    // Si el slot es una hora despu√©s del √∫ltimo slot seleccionado
    if (slot.hour === lastSlot.hour + 1) {
      const newSlots = [...sortedSlots, slot];
      setSelectedTimeSlots(newSlots);
      setSelectedTimeSlot(newSlots[0]); // Mantener el primer slot para compatibilidad
      return;
    }
    
    // Si el slot ya est√° seleccionado, deseleccionarlo
    if (selectedTimeSlots.some(s => s.hour === slot.hour)) {
      // Si solo hay un slot seleccionado, deseleccionar todo
      if (selectedTimeSlots.length === 1) {
        setSelectedTimeSlots([]);
        setSelectedTimeSlot(null);
        return;
      }
      
      // Si hay m√∫ltiples slots, verificar si el slot a deseleccionar rompe la secuencia
      if (slot.hour !== firstSlot.hour && slot.hour !== lastSlot.hour) {
        // No permitir deseleccionar slots intermedios
        Alert.alert(
          'Selecci√≥n no v√°lida', 
          'Solo puedes deseleccionar el primer o √∫ltimo slot de la secuencia.',
          [{ text: 'Entendido', style: 'cancel' }]
        );
        return;
      }
      
      // Deseleccionar el primer o √∫ltimo slot
      const newSlots = selectedTimeSlots.filter(s => s.hour !== slot.hour);
      setSelectedTimeSlots(newSlots);
      setSelectedTimeSlot(newSlots[0]); // Actualizar para compatibilidad
      return;
    }
    
    // Si el slot no es consecutivo, mostrar un mensaje
    Alert.alert(
      'Selecci√≥n no v√°lida', 
      'Solo puedes seleccionar slots consecutivos. Si necesitas m√°s tiempo, selecciona un slot que sea consecutivo con los ya seleccionados.',
      [{ text: 'Entendido', style: 'cancel' }]
    );
  };
  
  // Calcular la duraci√≥n total del evento en horas
  const calculateTotalDuration = () => {
    if (selectedTimeSlots.length === 0) return 0;
    
    // Ordenar los slots por hora
    const sortedSlots = [...selectedTimeSlots].sort((a, b) => a.hour - b.hour);
    
    // Calcular la duraci√≥n total
    const firstSlot = sortedSlots[0];
    const lastSlot = sortedSlots[sortedSlots.length - 1];
    
    return (lastSlot.hour + 1) - firstSlot.hour;
  };
  
  // Obtener el slot de inicio y fin para mostrar en el resumen
  const getTimeRange = () => {
    if (selectedTimeSlots.length === 0) return { start: '', end: '' };
    
    // Ordenar los slots por hora
    const sortedSlots = [...selectedTimeSlots].sort((a, b) => a.hour - b.hour);
    
    return {
      start: sortedSlots[0].start,
      end: sortedSlots[sortedSlots.length - 1].end
    };
  };
  
  // Cargar disponibilidad cuando el modal es visible
  useEffect(() => {
    if (visible && spaceId) {
      // Reiniciar estados
      setFilteredTimeSlots([]);
      setSelectedTimeSlot(null);
      setLoadingSlots(true);
      setEventDescription('');
      setEventDate(new Date());
      setExpectedAttendees('');
      setEventType('');
      setAdditionalRequirements('');
      setFilteredTimeSlots([]);
      setAvailableSlots([]);
      setBlockedSlots([]);
      
      // Usar setTimeout para asegurar que los estados se actualicen antes de cargar datos
      setTimeout(() => {
        // Cargar disponibilidad para la fecha actual
        loadAvailability();
        
        // Asegurar que se filtren los slots bloqueados correctamente
        setTimeout(() => {
          filterAvailableTimeSlots();
        }, 300);
      }, 100);
    }
  }, [visible, spaceId, managerId]);
  
  // Filtrar horarios disponibles cuando cambia la fecha o se cargan datos
  useEffect(() => {
    if (eventDate && availableSlots.length > 0) {
      // Asegurar que se filtren los horarios cuando cambian los datos relevantes
      console.log('Detectado cambio en fecha, slots disponibles o bloqueados - Filtrando horarios...');
      filterAvailableTimeSlots();
    } else if (eventDate && availableSlots.length === 0) {
      // Si no hay slots disponibles, limpiar los filtrados
      console.log('No hay slots disponibles para esta fecha');
      setFilteredTimeSlots([]);
      setLoadingSlots(false);
    }
  }, [eventDate, availableSlots, blockedSlots]);

  // Cargar datos de disponibilidad y bloqueos desde el backend
  const loadAvailabilityPromise = async (specificDate) => {
    return new Promise(async (resolve, reject) => {
      try {
        await loadAvailability(specificDate);
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  };
  
  // Versi√≥n promesa de loadBlockedSlotsForDate para manejar secuencias
  const loadBlockedSlotsPromise = async (specificDate) => {
    return new Promise(async (resolve, reject) => {
      try {
        await loadBlockedSlotsForDate(specificDate);
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  };
  
  // Cargar disponibilidad para la fecha seleccionada
  const loadAvailability = async (selectedDate = eventDate) => {
    if (!spaceId || !managerId) {
      console.error('No se puede cargar disponibilidad sin spaceId o managerId');
      return;
    }
    
    // Reiniciar estados relacionados con slots
    setFilteredTimeSlots([]);
    setAvailableSlots([]);
    setBlockedSlots([]);
    setSelectedTimeSlots([]);
    setSelectedTimeSlot(null);
    
    setLoadingSlots(true);
    try {
      // Usar la fecha espec√≠fica si se proporciona, o la fecha del evento seleccionada
      const dateToUse = selectedDate;
      const date = dateToUse.toISOString().split('T')[0]; // Formato YYYY-MM-DD
      const dayOfWeek = dateToUse.getDay(); // D√≠a de la semana (0-6)
      
      console.log(`Cargando disponibilidad para fecha: ${date}, d√≠a: ${getDayName(dayOfWeek)}`);
      
      // 1. Cargar los slots disponibles configurados por el gestor para la fecha espec√≠fica
      // Usamos el mismo endpoint que usa SpaceSchedule.js para obtener la disponibilidad espec√≠fica
      const availabilityUrl = `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}?date=${date}`;
      console.log(`Solicitando disponibilidad desde URL: ${availabilityUrl}`);
      
      const availabilityResponse = await axios.get(availabilityUrl);
      
      if (availabilityResponse.data) {
        console.log('Respuesta de disponibilidad recibida:', availabilityResponse.data);
        
        // Procesar los datos recibidos para asegurar que est√°n en el formato correcto
        const formattedAvailabilities = [];
        
        // Verificar si tenemos disponibilidad espec√≠fica para la fecha
        const availabilityData = availabilityResponse.data.availability || availabilityResponse.data;
        
        console.log('Datos de disponibilidad recibidos:', JSON.stringify(availabilityData, null, 2));
        
        // Si la respuesta tiene la estructura esperada
        if (typeof availabilityData === 'object') {
          // Verificar si hay configuraci√≥n espec√≠fica para la fecha seleccionada
          if (Object.keys(availabilityData).length === 0) {
            console.log(`No hay configuraci√≥n espec√≠fica para la fecha ${date}`);
            // No hay configuraci√≥n espec√≠fica, no mostramos franjas
            setAvailableSlots([]);
            return;
          }
          
          // Recorrer cada d√≠a en la respuesta
          for (const day in availabilityData) {
            // Asegurar que el d√≠a sea un n√∫mero
            const dayOfWeek = parseInt(day, 10);
            if (!isNaN(dayOfWeek)) {
              // Verificar si hay horas disponibles para este d√≠a
              const hoursArray = availabilityData[day];
              
              if (Array.isArray(hoursArray) && hoursArray.length > 0) {
                // Asegurar que las horas sean n√∫meros
                const hours = hoursArray.map(hour => {
                  return typeof hour === 'string' ? parseInt(hour, 10) : hour;
                }).filter(hour => !isNaN(hour));
                
                // Solo a√±adir d√≠as que tengan horas disponibles
                if (hours.length > 0) {
                  console.log(`Franjas para d√≠a ${getDayName(dayOfWeek)}: ${hours.join(', ')}`);
                  formattedAvailabilities.push({
                    day: getDayName(dayOfWeek),
                    dayOfWeek: dayOfWeek,
                    timeSlots: hours,
                    isSpecificDate: true // Indicar que es una configuraci√≥n espec√≠fica
                  });
                }
              }
            }
          }
        }
        
        console.log(`Disponibilidad cargada: ${formattedAvailabilities.length} d√≠as configurados`);
        formattedAvailabilities.forEach(day => {
          console.log(`D√≠a ${day.day}: ${day.timeSlots.length} franjas disponibles`);
        });
        
        // Si no hay disponibilidad para la fecha espec√≠fica, intentamos cargar la disponibilidad general para el d√≠a de la semana
        if (formattedAvailabilities.length === 0) {
          console.log(`No hay disponibilidad espec√≠fica para la fecha ${date}, intentando cargar disponibilidad general para el d√≠a ${getDayName(dayOfWeek)}`);
          
          // Cargar disponibilidad general para el d√≠a de la semana
          const generalUrl = `${BACKEND_URL}/api/cultural-spaces/general-availability/${managerId}`;
          console.log(`Solicitando disponibilidad general desde URL: ${generalUrl}`);
          
          try {
            const generalResponse = await axios.get(generalUrl);
            
            if (generalResponse.data) {
              const generalData = generalResponse.data.availability || generalResponse.data;
              
              if (typeof generalData === 'object') {
                // Buscar configuraci√≥n para el d√≠a de la semana actual
                const dayConfig = generalData[dayOfWeek];
                
                if (Array.isArray(dayConfig) && dayConfig.length > 0) {
                  // Asegurar que las horas sean n√∫meros
                  const hours = dayConfig.map(hour => {
                    return typeof hour === 'string' ? parseInt(hour, 10) : hour;
                  }).filter(hour => !isNaN(hour));
                  
                  if (hours.length > 0) {
                    console.log(`Franjas generales para d√≠a ${getDayName(dayOfWeek)}: ${hours.join(', ')}`);
                    formattedAvailabilities.push({
                      day: getDayName(dayOfWeek),
                      dayOfWeek: dayOfWeek,
                      timeSlots: hours,
                      isSpecificDate: false // Indicar que es una configuraci√≥n general
                    });
                  }
                }
              }
            }
          } catch (generalError) {
            console.error('Error al cargar disponibilidad general:', generalError);
          }
        }
        
        console.log(`Disponibilidad final: ${formattedAvailabilities.length} d√≠as configurados`);
        setAvailableSlots(formattedAvailabilities);
        
        // Actualizar los horarios filtrados inmediatamente
        setTimeout(() => {
          filterAvailableTimeSlots();
        }, 100);
      } else {
        console.error('No se recibieron datos de disponibilidad v√°lidos');
        Alert.alert(
          'Horarios no disponibles', 
          'No se pudieron cargar los horarios configurados para este espacio. Por favor, contacte al administrador.',
          [{ text: 'OK' }]
        );
        setAvailableSlots([]);
      }
      
      // 2. Cargar slots bloqueados (opcional)
      try {
        const blockedResponse = await axios.get(`${BACKEND_URL}/api/blocked-slots/space/${spaceId}`);
        
        if (blockedResponse.data.blockedSlots) {
          const blockedSlots = blockedResponse.data.blockedSlots;
          console.log(`Slots bloqueados cargados: ${blockedSlots.length}`);
          
          // Mostrar informaci√≥n detallada sobre los slots bloqueados
          blockedSlots.forEach(slot => {
            const slotDay = slot.day !== undefined ? getDayName(slot.day) : 'No especificado';
            const slotDate = slot.date || 'No especificada';
            console.log(`Slot bloqueado: D√≠a ${slotDay}, Hora ${slot.hour}:00, Fecha ${slotDate}, Recurrente: ${slot.isRecurring ? 'S√≠' : 'No'}`);
          });
          
          setBlockedSlots(blockedSlots);
        } else {
          console.log('No hay slots bloqueados configurados');
          setBlockedSlots([]);
        }
      } catch (blockedError) {
        console.error('Error al cargar slots bloqueados:', blockedError);
        setBlockedSlots([]);
      }
      
      // Ya no cargamos eventos aprobados, ya que no son necesarios para este formulario
      console.log('Omitiendo carga de eventos aprobados');
      
      // Actualizar los horarios filtrados despu√©s de cargar todos los datos
      setTimeout(() => {
        filterAvailableTimeSlots();
      }, 100);
      
    } catch (error) {
      console.error('Error al cargar disponibilidad:', error);
      Alert.alert(
        'Error', 
        'No se pudo cargar la disponibilidad del espacio. Por favor, int√©ntelo de nuevo m√°s tarde.',
        [{ text: 'OK' }]
      );
    } finally {
      setLoadingSlots(false);
    }
  };

  // Filtrar horarios disponibles para el d√≠a seleccionado
  const filterAvailableTimeSlots = (dateToFilter = null) => {
    // Usar la fecha proporcionada o la fecha actual del estado
    const dateToUse = dateToFilter || eventDate;
    if (!dateToUse) {
      console.log('No hay fecha seleccionada');
      setFilteredTimeSlots([]);
      setLoadingSlots(false);
      return;
    }
    
    // Obtener el d√≠a de la semana (0-6) de la fecha seleccionada
    const dayOfWeek = dateToUse.getDay();
    
    // Formatear la fecha seleccionada para comparaciones
    const date = dateToUse.toISOString().split('T')[0]; // Formato YYYY-MM-DD
    
    console.log(`Filtrando slots para fecha: ${date}, d√≠a: ${getDayName(dayOfWeek)}`);
    console.log(`Total slots bloqueados: ${blockedSlots.length}`);
    
    // Verificar si hay configuraci√≥n de disponibilidad cargada
    if (availableSlots.length === 0) {
      console.log('No hay configuraci√≥n de disponibilidad cargada para esta fecha');
      setFilteredTimeSlots([]);
      setLoadingSlots(false);
      return;
    }
    
    // Buscar configuraci√≥n de disponibilidad para este d√≠a
    const dayAvailability = availableSlots.find(slot => slot.dayOfWeek === dayOfWeek);
    
    if (!dayAvailability || !dayAvailability.timeSlots || dayAvailability.timeSlots.length === 0) {
      console.log(`No hay franjas configuradas para el d√≠a ${getDayName(dayOfWeek)}`);
      setFilteredTimeSlots([]);
      setLoadingSlots(false);
      return;
    }
    
    // Verificar si es una configuraci√≥n espec√≠fica para esta fecha
    if (dayAvailability.isSpecificDate) {
      console.log(`Usando configuraci√≥n ESPEC√çFICA para fecha ${date}`);
    } else {
      console.log(`Usando configuraci√≥n general para d√≠a ${getDayName(dayOfWeek)}`);
    }
    
    console.log(`Encontradas ${dayAvailability.timeSlots.length} franjas configuradas para ${getDayName(dayOfWeek)}`);
    
    // Crear array de slots disponibles
    const availableHours = dayAvailability.timeSlots.map(hour => {
      // Convertir a n√∫mero si es string
      const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
      
      // Formatear la hora para mostrar
      const formattedHour = hourNum < 10 ? `0${hourNum}:00` : `${hourNum}:00`;
      const period = hourNum >= 12 ? 'PM' : 'AM';
      const displayHour = hourNum > 12 ? hourNum - 12 : hourNum === 0 ? 12 : hourNum;
      const displayTime = `${displayHour}:00 ${period}`;
      
      // A√±adir horas de inicio y fin para el evento (siempre exactamente 1 hora)
      const startHour = `${hourNum < 10 ? '0' + hourNum : hourNum}:00:00`;
      const endHour = `${(hourNum + 1) < 10 ? '0' + (hourNum + 1) : (hourNum + 1)}:00:00`;
      
      // Calcular la duraci√≥n en horas
      const duration = (hourNum + 1) - hourNum;
      
      return {
        hour: hourNum,
        formattedHour,
        displayTime,
        start: startHour,
        end: endHour,
        duration: duration // A√±adir la duraci√≥n para filtrar despu√©s
      };
    });
    
    // Filtrar slots para asegurar que solo se muestren los que duran exactamente 1 hora
    const validDurationSlots = availableHours.filter(slot => slot.duration === 1);
    
    // Si hay slots que exceden la duraci√≥n m√°xima, mostrar un mensaje en la consola
    if (validDurationSlots.length < availableHours.length) {
      console.log(`Se filtraron ${availableHours.length - validDurationSlots.length} slots que exceden la duraci√≥n m√°xima de 1 hora`);
    }
    
    // Mostrar informaci√≥n detallada de todos los slots configurados
    console.log('Slots configurados antes de filtrar:');
    validDurationSlots.forEach(slot => {
      console.log(`- ${slot.displayTime} (Duraci√≥n: ${slot.duration} hora)`);
    });
    
    // Mostrar informaci√≥n detallada de todos los slots bloqueados
    console.log('Slots bloqueados:');
    blockedSlots.forEach(slot => {
      console.log(`- Hora ${slot.hour}:00, Fecha ${slot.date || 'Recurrente'}, D√≠a ${slot.day !== undefined ? getDayName(slot.day) : 'No especificado'}`);
    });
    
    // Ya tenemos la variable date definida arriba
    
    // Filtrar slots que ya est√°n bloqueados para esta fecha
    // Solo consideramos slots que tienen la duraci√≥n correcta (1 hora)
    const filteredHours = validDurationSlots.filter(slot => {
      // Verificar si este slot est√° bloqueado
      const isBlocked = blockedSlots.some(blockedSlot => {
        // Verificar si el slot bloqueado coincide con la hora actual
        const hourMatches = blockedSlot.hour === slot.hour;
        if (!hourMatches) return false;
        
        // Si el slot bloqueado es recurrente, verificar d√≠a de la semana
        if (blockedSlot.isRecurring) {
          // Verificar si el d√≠a coincide (usando day en lugar de dayOfWeek para compatibilidad)
          const dayMatches = blockedSlot.day === dayOfWeek;
          if (dayMatches) {
            console.log(`Slot ${slot.displayTime} bloqueado recurrentemente para ${getDayName(dayOfWeek)}`);
            return true;
          }
        }
        
        // Si no es recurrente, verificar fecha espec√≠fica
        if (blockedSlot.date) {
          // Asegurar que estamos comparando el mismo formato de fecha
          const blockedDate = blockedSlot.date;
          const dateMatches = blockedDate === date;
          
          if (dateMatches) {
            console.log(`Slot ${slot.displayTime} bloqueado espec√≠ficamente para la fecha ${date}`);
            return true;
          }
        }
        
        return false;
      });
      
      if (isBlocked) {
        console.log(`Excluyendo franja bloqueada: ${slot.displayTime}`);
      }
      
      // Solo incluir slots que no est√©n bloqueados
      return !isBlocked;
    });
    
    console.log(`Slots disponibles despu√©s de filtrar bloqueados: ${filteredHours.length}`);
    filteredHours.forEach(slot => {
      console.log(`Slot disponible: ${slot.displayTime} (Duraci√≥n: ${slot.duration} hora)`);
    });
    
    // Ya no filtramos por eventos aprobados, usamos directamente los slots disponibles despu√©s de filtrar bloqueados
    console.log(`Slots disponibles finales: ${filteredHours.length}`);
    setFilteredTimeSlots(filteredHours);
  };

  // Manejar cambio de fecha
  const handleDateChange = (event, selectedDate) => {
    setShowDatePicker(false);
    if (selectedDate) {
      console.log(`Fecha seleccionada cambiada a: ${selectedDate.toLocaleDateString()}, d√≠a: ${getDayName(selectedDate.getDay())}`);
      
      // Indicar que estamos cargando
      setLoadingSlots(true);
      
      // Limpiar estados previos
      setFilteredTimeSlots([]);
      setSelectedTimeSlots([]);
      setSelectedTimeSlot(null);
      
      // Guardar la fecha seleccionada para usarla en las funciones de carga
      const selectedDateCopy = new Date(selectedDate.getTime());
      
      // Actualizar la fecha en el estado
      setEventDate(selectedDate);
      
      // Cargar datos de forma sincronizada
      const loadDataForDate = async () => {
        try {
          // Limpiar datos anteriores
          setAvailableSlots([]);
          setBlockedSlots([]);
          
          // Cargar disponibilidad directamente sin esperar a que se actualice el estado
          console.log(`Cargando disponibilidad directamente para fecha: ${selectedDateCopy.toISOString().split('T')[0]}`);
          const availabilityData = await axios.get(`${BACKEND_URL}/api/cultural-spaces/availability/${managerId}?date=${selectedDateCopy.toISOString().split('T')[0]}`);
          
          // Procesar los datos de disponibilidad
          if (availabilityData.data) {
            const formattedAvailabilities = [];
            const availabilityDataObj = availabilityData.data.availability || availabilityData.data;
            
            if (typeof availabilityDataObj === 'object' && Object.keys(availabilityDataObj).length > 0) {
              for (const day in availabilityDataObj) {
                const dayOfWeek = parseInt(day, 10);
                if (!isNaN(dayOfWeek)) {
                  const hoursArray = availabilityDataObj[day];
                  
                  if (Array.isArray(hoursArray) && hoursArray.length > 0) {
                    const hours = hoursArray.map(hour => {
                      return typeof hour === 'string' ? parseInt(hour, 10) : hour;
                    }).filter(hour => !isNaN(hour));
                    
                    if (hours.length > 0) {
                      formattedAvailabilities.push({
                        day: getDayName(dayOfWeek),
                        dayOfWeek: dayOfWeek,
                        timeSlots: hours,
                        isSpecificDate: true
                      });
                    }
                  }
                }
              }
            }
            
            // Cargar slots bloqueados
            const date = selectedDateCopy.toISOString().split('T')[0];
            const dayOfWeek = selectedDateCopy.getDay();
            
            // Cargar slots bloqueados espec√≠ficos
            const blockedResponse = await axios.get(`${BACKEND_URL}/api/spaces/blocked-slots/${managerId}?date=${date}`);
            const allBlockedSlots = blockedResponse.data && blockedResponse.data.blockedSlots ? blockedResponse.data.blockedSlots : [];
            
            // Actualizar los estados con los datos cargados
            setAvailableSlots(formattedAvailabilities);
            setBlockedSlots(allBlockedSlots);
            
            // Filtrar los slots disponibles inmediatamente
            if (formattedAvailabilities.length > 0) {
              // Crear array de slots disponibles para el d√≠a seleccionado
              const dayAvailability = formattedAvailabilities.find(slot => slot.dayOfWeek === dayOfWeek);
              
              if (dayAvailability && dayAvailability.timeSlots && dayAvailability.timeSlots.length > 0) {
                const availableHours = dayAvailability.timeSlots.map(hour => {
                  const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
                  
                  const formattedHour = hourNum < 10 ? `0${hourNum}:00` : `${hourNum}:00`;
                  const period = hourNum >= 12 ? 'PM' : 'AM';
                  const displayHour = hourNum > 12 ? hourNum - 12 : hourNum === 0 ? 12 : hourNum;
                  const displayTime = `${displayHour}:00 ${period}`;
                  
                  const startHour = `${hourNum < 10 ? '0' + hourNum : hourNum}:00:00`;
                  const endHour = `${(hourNum + 1) < 10 ? '0' + (hourNum + 1) : (hourNum + 1)}:00:00`;
                  
                  return {
                    hour: hourNum,
                    formattedHour,
                    displayTime,
                    start: startHour,
                    end: endHour
                  };
                });
                
                // Filtrar slots bloqueados
                const filteredHours = availableHours.filter(slot => {
                  return !allBlockedSlots.some(blockedSlot => {
                    return blockedSlot.hour === slot.hour && 
                           ((blockedSlot.isRecurring && blockedSlot.day === dayOfWeek) || 
                            (blockedSlot.date === date));
                  });
                });
                
                // Actualizar los slots filtrados
                setFilteredTimeSlots(filteredHours);
              } else {
                setFilteredTimeSlots([]);
              }
            } else {
              setFilteredTimeSlots([]);
            }
          }
          
          // Finalizar la carga
          setLoadingSlots(false);
        } catch (error) {
          console.error('Error al cargar datos para la fecha:', error);
          setLoadingSlots(false);
          setFilteredTimeSlots([]);
        }
      };
      
      // Iniciar la carga de datos inmediatamente
      loadDataForDate();
    }
  };

  // Cargar slots bloqueados para una fecha espec√≠fica
  const loadBlockedSlotsForDate = async (specificDate) => {
    try {
      const date = specificDate.toISOString().split('T')[0]; // Formato YYYY-MM-DD
      const dayOfWeek = specificDate.getDay(); // D√≠a de la semana (0-6)
      console.log(`Cargando slots bloqueados para fecha: ${date}, d√≠a: ${getDayName(dayOfWeek)}`);
      
      // Primero, intentamos cargar los slots bloqueados espec√≠ficos para esta fecha
      const specificUrl = `${BACKEND_URL}/api/spaces/blocked-slots/${managerId}?date=${date}`;
      console.log(`Solicitando slots bloqueados espec√≠ficos desde URL: ${specificUrl}`);
      
      const specificResponse = await axios.get(specificUrl);
      let allBlockedSlots = [];
      
      // Procesamos los slots bloqueados espec√≠ficos para esta fecha
      if (specificResponse.data && specificResponse.data.blockedSlots) {
        const specificBlockedSlots = specificResponse.data.blockedSlots;
        console.log(`Slots bloqueados espec√≠ficos para fecha ${date}: ${specificBlockedSlots.length}`);
        
        // Filtrar solo los slots bloqueados espec√≠ficos para esta fecha
        const dateSpecificSlots = specificBlockedSlots.filter(slot => {
          if (slot.date === date) {
            console.log(`Slot bloqueado espec√≠fico para fecha ${date}: Hora ${slot.hour}:00`);
            return true;
          }
          return false;
        });
        
        allBlockedSlots = [...dateSpecificSlots];
      }
      
      // Ahora, cargamos los slots bloqueados recurrentes para este d√≠a de la semana
      const recurringUrl = `${BACKEND_URL}/api/spaces/blocked-slots/${managerId}?recurring=true&day=${dayOfWeek}`;
      console.log(`Solicitando slots bloqueados recurrentes desde URL: ${recurringUrl}`);
      
      const recurringResponse = await axios.get(recurringUrl);
      
      // Procesamos los slots bloqueados recurrentes para este d√≠a de la semana
      if (recurringResponse.data && recurringResponse.data.blockedSlots) {
        const recurringBlockedSlots = recurringResponse.data.blockedSlots;
        console.log(`Slots bloqueados recurrentes para d√≠a ${getDayName(dayOfWeek)}: ${recurringBlockedSlots.length}`);
        
        // Filtrar solo los slots bloqueados recurrentes para este d√≠a de la semana
        const dayRecurringSlots = recurringBlockedSlots.filter(slot => {
          if (slot.isRecurring && slot.day === dayOfWeek) {
            console.log(`Slot bloqueado recurrente para d√≠a ${getDayName(dayOfWeek)}: Hora ${slot.hour}:00`);
            return true;
          }
          return false;
        });
        
        // Combinar los slots bloqueados espec√≠ficos y recurrentes
        allBlockedSlots = [...allBlockedSlots, ...dayRecurringSlots];
      }
      
      // Eliminar duplicados (misma hora)
      const uniqueBlockedSlots = [];
      const seenHours = new Set();
      
      allBlockedSlots.forEach(slot => {
        if (!seenHours.has(slot.hour)) {
          seenHours.add(slot.hour);
          uniqueBlockedSlots.push(slot);
        }
      });
      
      console.log(`Total slots bloqueados para fecha ${date}: ${uniqueBlockedSlots.length}`);
      
      // Mostrar informaci√≥n detallada sobre los slots bloqueados
      uniqueBlockedSlots.forEach(slot => {
        const slotDay = slot.day !== undefined ? getDayName(slot.day) : 'No especificado';
        const slotDate = slot.date || 'No especificada';
        const slotHour = slot.hour < 10 ? `0${slot.hour}:00` : `${slot.hour}:00`;
        const slotType = slot.isRecurring ? 'Recurrente' : 'Espec√≠fico';
        console.log(`Slot bloqueado (${slotType}): D√≠a ${slotDay}, Hora ${slotHour}, Fecha ${slotDate}`);
      });
      
      // Guardar los slots bloqueados en el estado
      setBlockedSlots(uniqueBlockedSlots);
      
      // Volver a filtrar los slots disponibles con los nuevos datos de bloqueo
      setTimeout(() => filterAvailableTimeSlots(), 100);
    } catch (error) {
      console.error('Error al cargar slots bloqueados para fecha espec√≠fica:', error);
      setBlockedSlots([]);
      // Volver a filtrar los slots disponibles sin bloqueos
      setTimeout(() => filterAvailableTimeSlots(), 100);
    }
  };

  // Mostrar resumen y confirmar env√≠o
  const showSummaryAndConfirm = () => {
    if (!eventName || !eventDescription || selectedTimeSlots.length === 0 || !expectedAttendees || !eventType) {
      Alert.alert('Campos incompletos', 'Por favor complete todos los campos obligatorios');
      return;
    }
    
    // Calcular la duraci√≥n total del evento
    const totalDuration = calculateTotalDuration();
    
    // Obtener el rango de tiempo
    const timeRange = getTimeRange();
    
    // Formatear la hora para mostrar en formato m√°s amigable
    const formatTime = (timeString) => {
      const [hour, minute] = timeString.split(':').map(num => parseInt(num, 10));
      const period = hour >= 12 ? 'PM' : 'AM';
      const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
      return `${displayHour}:00 ${period}`;
    };
    
    // Formatear la categor√≠a
    const formattedCategory = eventCategory === 'otro' 
      ? customCategory.trim() 
      : getCategoryLabel(eventCategory);
    
    // Mostrar resumen de la solicitud con estilo m√°s profesional
    Alert.alert(
      'Resumen de Solicitud', 
      `üìÖ Fecha: ${eventDate.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}\n\n` +
      `‚è∞ Horario: ${formatTime(timeRange.start)} - ${formatTime(timeRange.end)}\n` +
      `‚è±Ô∏è Duraci√≥n: ${totalDuration} ${totalDuration === 1 ? 'hora' : 'horas'}\n\n` +
      `üìã Detalles del evento:\n` +
      `‚Ä¢ Nombre: ${eventName}\n` +
      `‚Ä¢ Tipo: ${eventType}\n` +
      `‚Ä¢ Categor√≠a: ${formattedCategory}\n` +
      `‚Ä¢ Asistentes esperados: ${expectedAttendees}\n\n` +
      `${selectedTimeSlots.length > 1 ? `Has seleccionado ${selectedTimeSlots.length} franjas horarias consecutivas.` : ''}\n` +
      `${selectedTimeSlots.length === 1 ? 'Si necesitas m√°s tiempo, puedes seleccionar slots adicionales consecutivos.' : ''}\n\n` +
      `¬øConfirmas el env√≠o de esta solicitud?`,
      [
        { text: 'Cancelar', style: 'cancel' },
        { text: 'Confirmar', onPress: () => handleSubmit(), style: 'default', color: '#FF3A5E' }
      ]
    );
  };
  
  // Enviar solicitud de evento al endpoint sin token de autenticaci√≥n
const handleSubmit = async () => {
  setLoading(true);
  try {
    // Obtener el rango de tiempo de los slots seleccionados
    const timeRange = getTimeRange();
    
    // Crear los datos de la solicitud
    const requestData = {
      artistId: user.id,
      managerId: managerId,
      spaceId: spaceId,
      titulo: eventName,
      descripcion: eventDescription,
      fecha: eventDate.toISOString().split('T')[0],
      horaInicio: timeRange.start,
      horaFin: timeRange.end,
      duracionHoras: calculateTotalDuration(),
      asistentesEsperados: parseInt(expectedAttendees, 10),
      tipoEvento: eventType,
      categoria: eventCategory,
      categoriaPersonalizada: eventCategory === 'otro' ? customCategory.trim() : null,
      requerimientosAdicionales: additionalRequirements || 'Ninguno',
      estado: 'pendiente'
    };

    console.log('Datos de la solicitud:', JSON.stringify(requestData));
    
    // Verificar que el usuario est√© autenticado
    if (!user || !user.id) {
      Alert.alert(
        'Error de autenticaci√≥n', 
        'No se pudo verificar tu identidad. Por favor, inicia sesi√≥n nuevamente.',
        [{ text: 'Entendido', style: 'cancel' }]
      );
      setLoading(false);
      return;
    }
    
    try {
      console.log('Enviando solicitud sin token...');
      
      // Preparar los datos para el endpoint alternativo sin token
      const dataToSend = {
        ...requestData,
        artistEmail: user.email,  // Incluir email para verificaci√≥n adicional
        oauth_id: user.id,  // Incluir ID de OAuth para verificaci√≥n en backend
        // Asegurar que todos los campos requeridos est√©n presentes
        artistId: user.id || '',
        managerId: requestData.managerId || '',
        // Convertir spaceId a n√∫mero entero si es posible, o usar 1 como valor por defecto
        spaceId: requestData.spaceId && !isNaN(parseInt(requestData.spaceId)) ? 
                parseInt(requestData.spaceId) : 1,
        titulo: requestData.titulo || '',
        descripcion: requestData.descripcion || '',
        fecha: requestData.fecha || new Date().toISOString().split('T')[0],
        horaInicio: requestData.horaInicio || '00:00:00',
        horaFin: requestData.horaFin || '01:00:00',
        duracionHoras: requestData.duracionHoras || 1,
        asistentesEsperados: parseInt(requestData.asistentesEsperados) || 0,
        tipoEvento: requestData.tipoEvento || '',
        categoria: requestData.categoria || '',
        requerimientosAdicionales: requestData.requerimientosAdicionales || ''
      };
      
      console.log('Enviando datos al endpoint sin token:', dataToSend);
      
      // Enviar la solicitud al endpoint alternativo que no requiere token
      const response = await axios.post(`${BACKEND_URL}/api/event-requests/artist-submit`, dataToSend, {
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('Respuesta exitosa del servidor:', response.data);
      
      // Mostrar mensaje de √©xito con el color de acento rojo (#FF3A5E)
      Alert.alert(
        'Solicitud Enviada', 
        'Tu solicitud ha sido enviada con √©xito. El gestor del espacio te notificar√° cuando sea revisada.',
        [{ text: 'OK', onPress: () => {
          // Limpiar formulario
          setEventName('');
          setEventDescription('');
          setEventDate(new Date());
          setSelectedTimeSlots([]);
          setSelectedTimeSlot(null);
          setExpectedAttendees('');
          setEventType('');
          setEventCategory('otro');
          setCustomCategory('');
          setAdditionalRequirements('');
          // Cerrar modal
          onClose();
        }}]
      );
    } catch (error) {
      setIsSubmitting(false);
      console.error('Error al enviar solicitud:', error);

      let errorMessage = 'Ocurri√≥ un error al enviar la solicitud. Por favor, int√©ntalo de nuevo.';

      if (error.response) {
        // El servidor respondi√≥ con un c√≥digo de error
        console.error('Error de respuesta:', error.response.data);
        if (error.response.status === 401) {
          errorMessage = 'No est√°s autorizado para realizar esta acci√≥n. Por favor, inicia sesi√≥n nuevamente.';
        } else if (error.response.status === 403) {
          errorMessage = 'No tienes permisos para realizar esta acci√≥n.';
        } else if (error.response.status === 500) {
          errorMessage = 'Error en el servidor. El equipo t√©cnico ha sido notificado. Por favor, int√©ntalo m√°s tarde.';
          // Intentar extraer m√°s informaci√≥n del error para mostrar un mensaje m√°s espec√≠fico
          if (error.response.data && error.response.data.error) {
            if (error.response.data.error.includes('foreign key constraint')) {
              errorMessage = 'Error de referencia: Uno de los datos proporcionados no existe en el sistema.';
            } else if (error.response.data.error.includes('null')) {
              errorMessage = 'Faltan datos obligatorios en el formulario. Por favor, completa todos los campos requeridos.';
            }
          }
        } else if (error.response.data && error.response.data.message) {
          errorMessage = error.response.data.message;
        }
      } else if (error.request) {
        // La solicitud fue hecha pero no se recibi√≥ respuesta
        console.error('Error de solicitud:', error.request);
        errorMessage = 'No se pudo conectar con el servidor. Verifica tu conexi√≥n a internet.';
      }

      // Mostrar el error en la interfaz con el color de acento rojo (#FF3A5E)
      setError(errorMessage);
      setSuccessMessage('');

      // Hacer scroll hasta el mensaje de error para que el usuario lo vea
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  } catch (outerError) {
    console.error('Error inesperado:', outerError);
    Alert.alert('Error Inesperado', 'Ha ocurrido un error inesperado. Por favor, int√©ntalo de nuevo m√°s tarde.');
  } finally {
    setLoading(false);
  }
};

  return (
    <Modal
      visible={visible}
      animationType="fade"
      transparent={true}
      onRequestClose={onClose}
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <Text style={styles.title}>Solicitar Evento</Text>
              <Text style={styles.spaceName}>{spaceName}</Text>
            </View>
            <TouchableOpacity style={styles.closeButton} onPress={onClose}>
              <Ionicons name="close" size={24} color="#FF3A5E" />
            </TouchableOpacity>
          </View>
          
          <View style={styles.headerDivider} />
          
          <ScrollView 
            showsVerticalScrollIndicator={true} 
            persistentScrollbar={true} 
            contentContainerStyle={styles.scrollContent}
          >
            <View style={styles.formGroup}>
              <Text style={styles.label}>Nombre del evento *</Text>
              <TextInput
                style={styles.input}
                placeholder="Ej. Concierto de Jazz"
                placeholderTextColor="#999"
                value={eventName}
                onChangeText={setEventName}
              />
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Descripci√≥n *</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                placeholder="Describe brevemente el evento"
                placeholderTextColor="#999"
                multiline
                numberOfLines={4}
                value={eventDescription}
                onChangeText={setEventDescription}
              />
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Fecha *</Text>
              <View style={styles.dateContainer}>
                <TouchableOpacity 
                  style={styles.datePickerButton}
                  onPress={() => setShowDatePicker(true)}
                >
                  <Ionicons name="calendar" size={20} color="#FF3A5E" style={styles.dateIcon} />
                  <Text style={styles.dateText}>
                    {eventDate.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}
                  </Text>
                  <View style={styles.dateIndicator}>
                    <Ionicons name="chevron-down" size={16} color="#FF3A5E" />
                  </View>
                </TouchableOpacity>
                <Text style={styles.dateHint}>Selecciona una fecha para ver los horarios disponibles</Text>
              </View>
              {showDatePicker && (
                <DateTimePicker
                  value={eventDate}
                  mode="date"
                  display="default"
                  onChange={handleDateChange}
                  minimumDate={new Date()}
                />
              )}
            </View>

            <View style={styles.formGroup}>
              <View style={styles.sectionHeader}>
                <Text style={styles.label}>Horario disponible *</Text>
                {filteredTimeSlots.length > 0 && (
                  <View style={styles.badgeContainer}>
                    <Text style={styles.badgeText}>{filteredTimeSlots.length}</Text>
                  </View>
                )}
              </View>
              <Text style={styles.infoText}>Selecciona un horario disponible para tu evento</Text>
              
              {/* Indicador de selecci√≥n m√∫ltiple */}
              {selectedTimeSlots.length > 0 && (
                <View style={styles.multiSelectInfo}>
                  <Ionicons name="information-circle" size={16} color="#FF3A5E" style={{marginRight: 6}} />
                  <Text style={styles.multiSelectText}>
                    {selectedTimeSlots.length === 1 
                      ? "Puedes seleccionar slots adicionales consecutivos si necesitas m√°s tiempo" 
                      : `Has seleccionado ${selectedTimeSlots.length} slots consecutivos (${calculateTotalDuration()} horas)`}
                  </Text>
                </View>
              )}
              
              {loadingSlots ? (
                <View style={styles.loadingContainer}>
                  <ActivityIndicator size="large" color="#FF3A5E" />
                  <Text style={styles.loadingText}>Cargando horarios disponibles...</Text>
                </View>
              ) : filteredTimeSlots.length > 0 ? (
                <View style={styles.timeSlotListContainer}>
                  <View style={styles.timeSlotHeader}>
                    <View style={styles.timeSlotHeaderLeft}>
                      <Ionicons name="calendar" size={18} color="#FF3A5E" style={{marginRight: 8}} />
                      <Text style={styles.timeSlotHeaderText}>{eventDate.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric' })}</Text>
                    </View>
                    <View style={styles.timeSlotHeaderRight}>
                      <Ionicons name="time-outline" size={16} color="#FF3A5E" style={{marginRight: 4}} />
                      <Text style={styles.timeSlotCount}>{filteredTimeSlots.length} franjas</Text>
                    </View>
                  </View>
                  
                  <View style={styles.timeSlotScrollContainer}>
                    <ScrollView 
                      nestedScrollEnabled={true}
                      showsVerticalScrollIndicator={true}
                      persistentScrollbar={true}
                      contentContainerStyle={styles.timeSlotContentContainer}
                    >
                      {filteredTimeSlots.map((slot, index) => (
                        <TouchableOpacity
                          key={`time-slot-${index}`}
                          style={[
                            styles.timeSlot,
                            selectedTimeSlots.some(s => s.hour === slot.hour) ? styles.selectedTimeSlot : null
                          ]}
                          onPress={() => handleTimeSlotSelection(slot)}
                        >
                          <View style={styles.timeSlotIconContainer}>
                            <Ionicons 
                              name={selectedTimeSlots.some(s => s.hour === slot.hour) ? "checkmark-circle" : "time-outline"} 
                              size={20} 
                              color={selectedTimeSlots.some(s => s.hour === slot.hour) ? "white" : "#FF3A5E"} 
                            />
                          </View>
                          <Text 
                            style={[
                              styles.timeSlotText,
                              selectedTimeSlots.some(s => s.hour === slot.hour) ? styles.selectedTimeSlotText : null
                            ]}
                          >
                            {slot.displayTime}
                          </Text>
                        </TouchableOpacity>
                      ))}
                    </ScrollView>
                  </View>
                </View>
              ) : (
                <View style={styles.noSlotsContainer}>
                  <Ionicons name="alert-circle-outline" size={24} color="#FF3A5E" />
                  <View style={styles.noSlotsTextContainer}>
                    <Text style={styles.noSlotsTitle}>No hay horarios disponibles</Text>
                    <Text style={styles.noSlotsText}>
                      No se encontraron franjas horarias disponibles para esta fecha. Por favor, selecciona otra fecha.
                    </Text>
                  </View>
                </View>
              )}
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Asistentes esperados *</Text>
              <TextInput
                style={styles.input}
                placeholder="Ej. 50"
                placeholderTextColor="#999"
                keyboardType="number-pad"
                value={expectedAttendees}
                onChangeText={setExpectedAttendees}
              />
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Tipo de evento *</Text>
              <TextInput
                style={styles.input}
                placeholder="Ej. Concierto, exposici√≥n, taller"
                placeholderTextColor="#999"
                value={eventType}
                onChangeText={setEventType}
              />
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Categor√≠a *</Text>
              <View style={styles.categoryContainer}>
                {['musica', 'teatro', 'danza', 'arte', 'literatura', 'cine', 'otro'].map((cat) => (
                  <TouchableOpacity
                    key={cat}
                    style={[
                      styles.categoryButton,
                      eventCategory === cat && styles.categoryButtonActive
                    ]}
                    onPress={() => setEventCategory(cat)}
                  >
                    <Text 
                      style={[
                        styles.categoryButtonText,
                        eventCategory === cat && styles.categoryButtonTextActive
                      ]}
                    >
                      {cat.charAt(0).toUpperCase() + cat.slice(1)}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
              
              {eventCategory === 'otro' && (
                <View style={styles.customCategoryContainer}>
                  <TextInput
                    style={styles.input}
                    placeholder="Especifica otra categor√≠a"
                    placeholderTextColor="#999"
                    value={customCategory}
                    onChangeText={setCustomCategory}
                  />
                </View>
              )}
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Requerimientos adicionales</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                placeholder="Ej. Equipo de sonido, proyector, etc."
                placeholderTextColor="#999"
                multiline
                numberOfLines={4}
                value={additionalRequirements}
                onChangeText={setAdditionalRequirements}
              />
            </View>

            <TouchableOpacity 
              style={styles.submitButton}
              onPress={showSummaryAndConfirm}
              disabled={loading}
            >
              {loading ? (
                <View style={styles.submitButtonContent}>
                  <ActivityIndicator size="small" color="#FFFFFF" />
                  <Text style={styles.submitButtonText}>Procesando...</Text>
                </View>
              ) : (
                <View style={styles.submitButtonContent}>
                  <Ionicons name="paper-plane" size={18} color="#FFFFFF" style={styles.submitButtonIcon} />
                  <Text style={styles.submitButtonText}>Enviar Solicitud</Text>
                </View>
              )}
            </TouchableOpacity>
          </ScrollView>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 15,
  },
  modalContent: {
    backgroundColor: '#1E1E1E',
    borderRadius: 15,
    padding: 20,
    width: '100%',
    maxWidth: 500,
    maxHeight: '90%',
    borderLeftWidth: 4,
    borderLeftColor: '#FF3A5E',
  },
  scrollContent: {
    paddingBottom: 20, // A√±adir espacio adicional al final del contenido
    paddingHorizontal: 5,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  headerContent: {
    flex: 1,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 5,
  },
  closeButton: {
    padding: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 58, 94, 0.1)',
  },
  spaceName: {
    fontSize: 16,
    fontWeight: '500',
    color: '#FF3A5E',
  },
  headerDivider: {
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 20,
  },
  formGroup: {
    marginBottom: 15,
  },
  label: {
    fontSize: 14,
    color: '#FFFFFF',
    marginBottom: 5,
    fontWeight: 'bold',
  },
  input: {
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    padding: 12,
    color: '#FFFFFF',
    borderWidth: 1,
    borderColor: 'rgba(255, 58, 94, 0.3)',
  },
  textArea: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  dateContainer: {
    marginBottom: 5,
  },
  datePickerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 58, 94, 0.3)',
  },
  dateIcon: {
    marginRight: 10,
  },
  dateText: {
    color: '#FFFFFF',
    flex: 1,
  },
  dateIndicator: {
    backgroundColor: 'rgba(255, 58, 94, 0.1)',
    borderRadius: 12,
    padding: 4,
  },
  dateHint: {
    fontSize: 12,
    color: '#999',
    fontStyle: 'italic',
    marginTop: 5,
    marginLeft: 5,
  },
  timeSlotListContainer: {
    marginTop: 10,
    marginBottom: 15,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 58, 94, 0.3)',
  },
  timeSlotHeader: {
    backgroundColor: 'rgba(255, 58, 94, 0.1)',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 58, 94, 0.3)',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  timeSlotHeaderLeft: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  timeSlotHeaderRight: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 58, 94, 0.2)',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 3,
  },
  timeSlotHeaderText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    fontSize: 14,
  },
  timeSlotCount: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: 'bold',
  },
  timeSlotListContent: {
    paddingBottom: 5,
  },
  timeSlotScrollContainer: {
    height: 200,
    flexGrow: 0,
  },
  timeSlotContentContainer: {
    flexGrow: 1,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 5,
  },
  badgeContainer: {
    backgroundColor: '#FF3A5E',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 2,
  },
  badgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
  },
  infoText: {
    fontSize: 13,
    color: '#999',
    marginBottom: 10,
    fontStyle: 'italic',
  },
  loadingContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 58, 94, 0.3)',
    marginTop: 10,
  },
  loadingText: {
    color: '#FFFFFF',
    marginTop: 10,
    fontSize: 14,
  },
  timeSlot: {
    backgroundColor: '#2A2A2A',
    paddingHorizontal: 15,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 58, 94, 0.2)',
    flexDirection: 'row',
    alignItems: 'center'
  },
  timeSlotIconContainer: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedTimeSlot: {
    backgroundColor: '#FF3A5E'
  },
  timeSlotText: {
    fontSize: 15,
    color: '#FFFFFF',
    marginLeft: 10,
    flex: 1,
  },
  selectedTimeSlotText: {
    color: 'white',
    fontWeight: 'bold'
  },
  noSlotsContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    backgroundColor: 'rgba(255, 58, 94, 0.05)',
    borderRadius: 8,
    padding: 15,
    marginTop: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 58, 94, 0.3)',
  },
  noSlotsTextContainer: {
    flex: 1,
    marginLeft: 10,
  },
  
  // Estilos para la informaci√≥n de selecci√≥n m√∫ltiple
  multiSelectInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF0F3',
    borderRadius: 8,
    padding: 10,
    marginTop: 8,
    marginBottom: 12,
    borderLeftWidth: 3,
    borderLeftColor: '#FF3A5E',
  },
  multiSelectText: {
    fontSize: 13,
    color: '#333',
    flex: 1,
    flexWrap: 'wrap',
  },
  noSlotsTitle: {
    color: '#FF3A5E',
    fontWeight: 'bold',
    fontSize: 14,
    marginBottom: 5,
  },
  noSlotsText: {
    color: '#FFFFFF',
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 18,
  },
  submitButton: {
    backgroundColor: '#FF3A5E',
    borderRadius: 25,
    padding: 15,
    marginTop: 20,
    marginBottom: 20,
    elevation: 3,
    shadowColor: '#FF3A5E',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
  },
  submitButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  submitButtonIcon: {
    marginRight: 8,
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    fontSize: 16,
  },
  categoryContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
    marginBottom: 8,
  },
  categoryButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginRight: 8,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: 'transparent',
  },
  categoryButtonActive: {
    backgroundColor: 'rgba(255, 58, 94, 0.2)',
    borderColor: '#FF3A5E',
  },
  categoryButtonText: {
    color: '#CCCCCC',
    fontSize: 14,
  },
  categoryButtonTextActive: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  customCategoryContainer: {
    marginTop: 10,
  },
});

export default EventRequestForm;

