import React, { useState, useEffect, useMemo } from 'react';
import { View, Text, TouchableOpacity, ScrollView, StyleSheet, Alert, ActivityIndicator, Modal, FlatList, Switch, DatePickerIOS, Platform, Button } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { useAuth } from '../context/AuthContext';
import axios from 'axios';
import { BACKEND_URL } from '../constants/config';
import AsyncStorage from '@react-native-async-storage/async-storage';
import DateTimePicker from '@react-native-community/datetimepicker';

const SpaceSchedule = ({ onClose }) => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [loading, setLoading] = useState(true);
  const [spaceData, setSpaceData] = useState(null);
  const [selectedDay, setSelectedDay] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [events, setEvents] = useState([]);
  const [availabilitySettings, setAvailabilitySettings] = useState({});
  const [blockedSlots, setBlockedSlots] = useState([]);
  const [isRecurring, setIsRecurring] = useState(false);
  const [modalMode, setModalMode] = useState('info'); // 'info', 'block', 'availability'
  const [viewMode, setViewMode] = useState('weekly'); // 'weekly', 'daily'
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [useSpecificDate, setUseSpecificDate] = useState(false);
  const [configSpecificDate, setConfigSpecificDate] = useState(null);
  const [showConfigDatePicker, setShowConfigDatePicker] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [showNotifications, setShowNotifications] = useState(true);
  const [selectedBlockedSlot, setSelectedBlockedSlot] = useState(null);

  // D√≠as de la semana
  const weekDays = [
    { id: 1, name: 'Lunes', shortName: 'Lun' },
    { id: 2, name: 'Martes', shortName: 'Mar' },
    { id: 3, name: 'Mi√©rcoles', shortName: 'Mi√©' },
    { id: 4, name: 'Jueves', shortName: 'Jue' },
    { id: 5, name: 'Viernes', shortName: 'Vie' },
    { id: 6, name: 'S√°bado', shortName: 'S√°b' },
    { id: 0, name: 'Domingo', shortName: 'Dom' }
  ];

  // Franjas horarias (de 6am a 10pm)
  const timeSlots = Array.from({ length: 17 }, (_, index) => {
    const hour = index + 6;
    return { 
      id: hour, 
      hour: hour > 12 ? hour - 12 : hour, 
      period: hour >= 12 ? 'PM' : 'AM' 
    };
  });

  // Funci√≥n para obtener las fechas de la semana actual
  const getCurrentWeekDates = () => {
    const today = new Date();
    const currentDay = today.getDay(); // 0 = domingo, 1 = lunes, ..., 6 = s√°bado
    const result = [];
    
    // Ajustar para que la semana comience en lunes (1)
    const firstDayOfWeek = 1; // Lunes
    
    // Calcular el lunes de la semana actual
    const mondayOffset = currentDay === 0 ? -6 : firstDayOfWeek - currentDay;
    const monday = new Date(today);
    monday.setDate(today.getDate() + mondayOffset);
    
    // Generar fechas para cada d√≠a de la semana (lunes a domingo)
    for (let i = 0; i < 7; i++) {
      const date = new Date(monday);
      date.setDate(monday.getDate() + i);
      result.push(date);
    }
    
    return result;
  };

  // Inicializar los d√≠as de la semana con sus fechas correspondientes
  const initializeWeekDaysWithDates = () => {
    const weekDates = getCurrentWeekDates();
    
    return weekDays.map((day, index) => {
      const date = weekDates[index];
      const formattedDate = date.toISOString().split('T')[0]; // Formato YYYY-MM-DD
      const displayDate = `${date.getDate()}/${date.getMonth() + 1}`; // Formato DD/MM
      
      return {
        ...day,
        date: formattedDate,
        displayDate: displayDate
      };
    });
  };

  // Inicializar los d√≠as de la semana con sus fechas
  const [weekDaysWithDates, setWeekDaysWithDates] = useState(initializeWeekDaysWithDates());

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      if (user && user.id) {
        try {
          // Cargar datos del espacio cultural primero
          await loadSpaceData();
          // Luego cargar el resto de los datos
          await loadEvents();
          await loadAvailabilitySettings();
          await loadBlockedSlots();
          
          // Seleccionar el primer d√≠a por defecto
          if (weekDays.length > 0) {
            setSelectedDay(weekDays[0]);
          }
        } catch (error) {
          console.error('Error al cargar datos:', error);
          initializeDefaultAvailability();
          setBlockedSlots([]);
        }
      } else {
        console.log('Usuario inv√°lido o sin ID, inicializando valores por defecto', user);
        initializeDefaultAvailability();
        setBlockedSlots([]);
      }
      setLoading(false);
    };
    
    loadData();
  }, [user]);
  
  // Cargar los datos iniciales cuando cambia el usuario
  useEffect(() => {
    const loadData = async () => {
      if (user && user.id) {
        setLoading(true);
        setManagerId(user.id);
        
        try {
          // Primero actualizar los d√≠as de la semana con sus fechas
          const updatedWeekDaysWithDates = initializeWeekDaysWithDates();
          setWeekDaysWithDates(updatedWeekDaysWithDates);
          
          // Luego cargar los slots bloqueados (esto crear√° el mapa de slots por fecha)
          await loadBlockedSlots();
          
          // Finalmente cargar la disponibilidad
          await loadAvailabilitySettings();
          
          // Seleccionar el d√≠a actual por defecto
          const today = new Date();
          const dayOfWeek = today.getDay(); // 0 = domingo, 1 = lunes, ..., 6 = s√°bado
          const adjustedDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek; // Convertir domingo (0) a 7
          
          // Encontrar el d√≠a correspondiente en weekDaysWithDates
          const todayDay = updatedWeekDaysWithDates.find(day => parseInt(day.id, 10) === adjustedDayOfWeek);
          
          if (todayDay) {
            console.log(`Seleccionando d√≠a inicial: ${todayDay.name} (${todayDay.date})`);
            setSelectedDay(todayDay);
            debugBlockedSlotsForDate(todayDay.date);
          }
        } catch (error) {
          console.error('Error al cargar datos iniciales:', error);
        } finally {
          setLoading(false);
        }
      }
    };
    
    loadData();
  }, [user]);

  // Crear un mapa de slots bloqueados por fecha
  const [blockedSlotsByDate, setBlockedSlotsByDate] = useState({});

  // Actualizar el mapa de slots bloqueados cuando cambian los slots
  useEffect(() => {
    // Crear un mapa de slots bloqueados por fecha
    const newBlockedSlotsByDate = {};
    
    blockedSlots.forEach(slot => {
      const slotDate = slot.dateStr || slot.date;
      
      if (slotDate) {
        if (!newBlockedSlotsByDate[slotDate]) {
          newBlockedSlotsByDate[slotDate] = [];
        }
        
        newBlockedSlotsByDate[slotDate].push(slot);
      }
    });
    
    console.log('Mapa de slots bloqueados por fecha creado:', newBlockedSlotsByDate);
    setBlockedSlotsByDate(newBlockedSlotsByDate);
  }, [blockedSlots]);

  // Funci√≥n para verificar si un slot est√° bloqueado para una fecha espec√≠fica
  const isSlotBlockedForSpecificDate = (hour, dateStr) => {
    if (!dateStr || !blockedSlotsByDate[dateStr]) {
      return false;
    }
    
    // Convertir a n√∫mero para comparaci√≥n consistente
    const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
    
    // Verificar directamente en el mapa de slots bloqueados por fecha
    const isBlocked = blockedSlotsByDate[dateStr].some(slot => {
      const slotHour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
      return slotHour === hourNum;
    });
    
    if (isBlocked) {
      console.log(`‚úÖ Slot bloqueado encontrado para fecha=${dateStr}, hora=${hourNum}`);
    }
    
    return isBlocked;
  };

  useEffect(() => {
    // Solo cargar si configSpecificDate tiene un valor y no estamos en medio de una configuraci√≥n
    if (configSpecificDate && !modalVisible && !isLoading) {
      // Usar un timeout para evitar m√∫ltiples actualizaciones en el mismo ciclo
      const timer = setTimeout(() => {
        loadSpecificDateAvailability(configSpecificDate);
      }, 300);
      
      return () => clearTimeout(timer);
    }
  }, [configSpecificDate, modalVisible]);

  // SOLUCI√ìN DEFINITIVA: Forzar la actualizaci√≥n de los d√≠as de la semana cuando cambian los slots bloqueados
  useEffect(() => {
    // Actualizar los d√≠as de la semana con sus fechas cada vez que cambian los slots bloqueados
    const updatedWeekDaysWithDates = initializeWeekDaysWithDates();
    setWeekDaysWithDates(updatedWeekDaysWithDates);
    
    // Si hay un d√≠a seleccionado, forzar su actualizaci√≥n
    if (selectedDay) {
      const updatedSelectedDay = updatedWeekDaysWithDates.find(day => day.id === selectedDay.id);
      if (updatedSelectedDay) {
        setSelectedDay(updatedSelectedDay);
      }
    }
  }, [blockedSlots]);

  // Funci√≥n para obtener el ID del manager de forma segura
  const getValidManagerId = () => {
    if (!user) {
      console.log('Usuario no disponible');
      return null;
    }
    
    // Preferir siempre el ID de OAuth si est√° disponible
    if (user.sub) {
      console.log('Usando sub del usuario (OAuth ID):', user.sub);
      return user.sub;
    }
    
    // En SpaceAvailabilityManager se usa _id directamente
    if (user._id) {
      console.log('Usando _id del usuario:', user._id);
      return user._id;
    }
    
    // Si no hay _id pero hay id, usamos ese
    if (user.id) {
      console.log('Usando id del usuario:', user.id);
      return user.id;
    }
    
    console.log('Usuario sin ID v√°lido');
    return null;
  };

  // Funci√≥n para guardar la configuraci√≥n de disponibilidad
  const saveAvailabilityToStorage = async (settings) => {
    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.log('No se pudo guardar disponibilidad: ID de manager inv√°lido');
        return;
      }
      
      // Guardar en AsyncStorage
      const key = `availability_${managerId}`;
      await AsyncStorage.setItem(key, JSON.stringify(settings));
      console.log('Disponibilidad guardada correctamente');
    } catch (error) {
      console.log('Error al guardar la disponibilidad en el almacenamiento local:', error);
    }
  };

  // Funci√≥n para guardar los slots bloqueados
  const saveBlockedSlotsToStorage = async (slots) => {
    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.log('No se pudo guardar slots bloqueados: ID de manager inv√°lido');
        return;
      }
      
      // Asegurarnos de que los slots tengan el formato correcto antes de guardarlos
      const formattedSlots = slots.map(slot => {
        // Asegurarnos de que day y hour sean n√∫meros
        const day = typeof slot.day === 'string' ? parseInt(slot.day, 10) : slot.day;
        const hour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
        
        return {
          ...slot,
          day: day,
          hour: hour,
          // A√±adir un campo compuesto para facilitar la b√∫squeda exacta
          dayHourKey: `${day}-${hour}`
        };
      });
      
      // Guardar en AsyncStorage
      const key = `blockedSlots_${managerId}`;
      await AsyncStorage.setItem(key, JSON.stringify(formattedSlots));
      console.log('Slots bloqueados guardados correctamente:', formattedSlots);
    } catch (error) {
      console.log('Error al guardar slots bloqueados en el almacenamiento local:', error);
    }
  };

  const loadSpaceData = async () => {
    if (!user) {
      console.log('No hay usuario autenticado');
      return null;
    }

    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.log('ID de manager inv√°lido, no se cargar√° informaci√≥n de espacio');
        return null;
      }

      // Cargar datos del espacio cultural
      console.log(`Cargando datos del espacio cultural para manager ID: ${managerId}`);
      const response = await axios.get(`${BACKEND_URL}/api/cultural-spaces/manager/${managerId}`);
      
      if (response.data && response.data.success && response.data.space) {
        console.log('Datos del espacio cultural cargados correctamente:', response.data.space);
        setSpaceData(response.data.space);
        return response.data.space;
      } else {
        console.log('No se encontr√≥ informaci√≥n del espacio cultural:', response.data);
        // Crear un objeto de espacio cultural por defecto
        const defaultSpace = {
          nombreEspacio: 'Mi Espacio Cultural',
          id: managerId
        };
        setSpaceData(defaultSpace);
        return defaultSpace;
      }
    } catch (error) {
      console.log('Error al cargar informaci√≥n del espacio cultural:', error.message);
      // En caso de error, establecer un nombre por defecto
      const defaultSpace = {
        nombreEspacio: 'Mi Espacio Cultural',
        id: getValidManagerId()
      };
      setSpaceData(defaultSpace);
      return defaultSpace;
    } 
  };

  const loadEvents = async () => {
    // Inicializar con array vac√≠o para evitar errores
    setEvents([]);
    
    try {
      // Intentar cargar eventos del backend
      const spaceId = user.id; // O usar el ID del espacio cultural si est√° disponible
      const response = await axios.get(`${BACKEND_URL}/api/events/space/${spaceId}`, {
        // Opci√≥n para evitar que se muestre el error en la consola
        validateStatus: (status) => {
          return status < 500; // Resuelve s√≥lo si el c√≥digo de estado es menor que 500
        }
      });
      
      if (response.data && response.data.success) {
        setEvents(response.data.events);
      }
    } catch (error) {
      console.error('Error al cargar eventos:', error);
      // Cargar datos ficticios para desarrollo si falla
      setEvents([]);
    }
  };

  const loadAvailabilitySettings = async (date = null) => {
    try {
      setIsLoading(true);
      
      const managerId = getValidManagerId();
      if (!managerId) {
        console.error('No se pudo cargar disponibilidad: ID de manager inv√°lido');
        setIsLoading(false);
        return;
      }
      
      // Construir la URL base
      let url = `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`;
      
      // Si hay una fecha espec√≠fica, a√±adirla como par√°metro
      if (date) {
        const dateString = date.toISOString().split('T')[0];
        url += `?date=${dateString}`;
        console.log(`Cargando disponibilidad para fecha espec√≠fica: ${dateString}`);
      }
      
      console.log(`Solicitando disponibilidad desde URL: ${url}`);
      
      const response = await axios.get(url, { timeout: 10000 });
      
      setIsLoading(false);
      
      if (response.data && response.data.success) {
        const availabilityData = response.data.availability;
        
        // Si estamos cargando una fecha espec√≠fica y no hay datos, pero tenemos canCreateConfig
        if (date && Object.keys(availabilityData).length === 0 && response.data.canCreateConfig) {
          console.log('No hay configuraci√≥n espec√≠fica para esta fecha, pero se puede crear');
          
          // Preguntar al usuario si desea crear una configuraci√≥n espec√≠fica
          if (!isConfiguringSpecificDate) {
            Alert.alert(
              'Configuraci√≥n no encontrada',
              `No hay configuraci√≥n espec√≠fica para ${date.toLocaleDateString()}. ¬øDeseas crear una?`,
              [
                {
                  text: 'No',
                  style: 'cancel',
                  onPress: () => {
                    // Volver a cargar la configuraci√≥n general
                    setUseSpecificDate(false);
                    setConfigSpecificDate(null);
                    loadAvailabilitySettings();
                  }
                },
                {
                  text: 'S√≠, configurar',
                  onPress: () => {
                    // Configurar para fecha espec√≠fica
                    setUseSpecificDate(true);
                    setConfigSpecificDate(date);
                    
                    // Abrir el modal para configurar
                    setModalMode('availability');
                    setModalVisible(true);
                  }
                }
              ]
            );
          }
          return;
        }
        
        // Actualizar el estado con los datos recibidos
        setAvailabilitySettings(availabilityData);
        console.log('Configuraci√≥n de disponibilidad cargada:', availabilityData);
        
        // Si hay fecha espec√≠fica en la respuesta, actualizar el estado
        if (response.data.isSpecificDate) {
          setUseSpecificDate(true);
          if (response.data.date) {
            setConfigSpecificDate(new Date(response.data.date));
          }
        }
      } else {
        console.error('Error al cargar disponibilidad:', response.data?.message);
      }
    } catch (error) {
      console.error('Error al cargar configuraci√≥n de disponibilidad:', error);
      setIsLoading(false);
    }
  };

  const loadBlockedSlots = async (showNotifications = true) => {
    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.error('ID de manager inv√°lido al cargar slots bloqueados');
        return;
      }
      
      console.log('üîç Buscando slots bloqueados para manager:', managerId);
      
      // Limpiar el estado actual
      setBlockedSlots([]);
      setBlockedSlotsByDate({});
      
      // Intentar cargar desde el servidor
      try {
        const response = await axios.get(`${BACKEND_URL}/api/spaces/blocked-slots/${managerId}`);
        
        if (response.data && response.data.success) {
          // Procesar los slots bloqueados del servidor
          const serverSlots = response.data.blockedSlots || [];
          console.log(`üìã Slots bloqueados recibidos del servidor: ${serverSlots.length}`);
          
          // Procesar los slots como en la versi√≥n anterior
          const processedSlots = serverSlots.map(slot => {
            // Asegurarnos de que hour sea n√∫mero
            const hour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
            
            // CORRECCI√ìN: SIEMPRE usar el d√≠a que viene de la base de datos
            const day = slot.day !== undefined ? 
              (typeof slot.day === 'string' ? parseInt(slot.day, 10) : slot.day) : 
              undefined;
            
            // Asegurarnos de que la fecha est√© presente
            const slotDate = slot.dateStr || slot.date;
            
            // Crear el slot con todos los campos necesarios
            return {
              id: slot.id || `server-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              hour: hour,
              date: slotDate,
              dateStr: slotDate,
              day: day,
              dayName: slot.dayName || (day ? getDayName(day) : null),
              fromServer: true
            };
          });
          
          console.log(`üìã Slots procesados: ${processedSlots.length}`);
          
          // Eliminar duplicados
          const uniqueSlots = processedSlots.filter((slot, index, self) => 
            index === self.findIndex(s => s.id === slot.id)
          );
          
          console.log(`üìã Slots bloqueados √∫nicos: ${uniqueSlots.length}`);
          
          // Actualizar el estado
          setBlockedSlots(uniqueSlots);
          
          // Crear el mapa de slots bloqueados por fecha
          const newBlockedSlotsByDate = {};
          
          uniqueSlots.forEach(slot => {
            const slotDate = slot.dateStr || slot.date;
            
            if (slotDate) {
              if (!newBlockedSlotsByDate[slotDate]) {
                newBlockedSlotsByDate[slotDate] = [];
              }
              
              newBlockedSlotsByDate[slotDate].push(slot);
            }
          });
          
          console.log('Mapa de slots bloqueados por fecha creado:', newBlockedSlotsByDate);
          setBlockedSlotsByDate(newBlockedSlotsByDate);
          
          // Guardar en AsyncStorage como respaldo
          await AsyncStorage.setItem(`blockedSlots_${managerId}`, JSON.stringify(uniqueSlots));
          
          // Ejecutar depuraci√≥n
          setTimeout(() => debugBlockedSlots(), 500);
          
          return uniqueSlots;
        }
      } catch (serverError) {
        console.error('Error al cargar slots bloqueados desde el servidor:', serverError);
        // Continuar con la carga desde AsyncStorage
      }
      
      // Si no se pudo cargar del servidor, intentar desde AsyncStorage
      const storedSlots = await AsyncStorage.getItem(`blockedSlots_${managerId}`);
      if (storedSlots) {
        const parsedSlots = JSON.parse(storedSlots);
        console.log(`üìã Slots bloqueados cargados desde AsyncStorage: ${parsedSlots.length}`);
        
        // Actualizar el estado
        setBlockedSlots(parsedSlots);
        
        // Crear el mapa de slots bloqueados por fecha
        const newBlockedSlotsByDate = {};
        
        parsedSlots.forEach(slot => {
          const slotDate = slot.dateStr || slot.date;
          
          if (slotDate) {
            if (!newBlockedSlotsByDate[slotDate]) {
              newBlockedSlotsByDate[slotDate] = [];
            }
            
            newBlockedSlotsByDate[slotDate].push(slot);
          }
        });
        
        console.log('Mapa de slots bloqueados por fecha creado desde AsyncStorage:', newBlockedSlotsByDate);
        setBlockedSlotsByDate(newBlockedSlotsByDate);
        
        // Ejecutar depuraci√≥n
        setTimeout(() => debugBlockedSlots(), 500);
        
        return parsedSlots;
      } else {
        console.log('No hay slots bloqueados guardados localmente');
        setBlockedSlots([]);
        setBlockedSlotsByDate({});
        return [];
      }
      
    } catch (error) {
      console.error('Error al cargar slots bloqueados:', error);
      if (showNotifications) {
        Alert.alert('Error', 'No se pudieron cargar los horarios bloqueados');
      }
      return [];
    }
  };

  // Funci√≥n para verificar si un slot est√° bloqueado
  const isSlotBlocked = (dayId, hourId, specificDate = null) => {
    if (!blockedSlots || blockedSlots.length === 0) {
      return false;
    }
    
    // Asegurarse de que los valores sean n√∫meros para comparaci√≥n consistente
    const day = typeof dayId === 'string' ? parseInt(dayId, 10) : dayId;
    const hour = typeof hourId === 'string' ? parseInt(hourId, 10) : hourId;
    
    // Si tenemos una fecha espec√≠fica, verificar por fecha
    if (specificDate && blockedSlotsByDate[specificDate]) {
      return blockedSlotsByDate[specificDate].some(slot => {
        const slotHour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
        return slotHour === hour;
      });
    }
    
    // Si no tenemos fecha espec√≠fica, verificar por d√≠a
    return blockedSlots.some(slot => {
      // Convertir valores a n√∫meros para comparaci√≥n consistente
      const slotDay = typeof slot.day === 'string' ? parseInt(slot.day, 10) : slot.day;
      const slotHour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
      
      // IMPORTANTE: Comparaci√≥n exacta de d√≠a y hora
      const exactMatch = slotDay === day && slotHour === hour && !slot.date;
      
      if (exactMatch) {
        console.log(`‚úÖ COINCIDENCIA EXACTA: D√≠a=${slotDay} (${getDayName(slotDay)}), Hora=${slotHour}`);
      }
      
      return exactMatch;
    });
  };

  const renderTimeSlot = ({ item: slot }) => {
    // Asegurarnos de que los IDs sean n√∫meros para comparaci√≥n consistente
    const dayId = selectedDay ? parseInt(selectedDay.id, 10) : null;
    const hourId = parseInt(slot.id, 10);
    
    // Obtener la fecha correspondiente al d√≠a seleccionado
    const selectedDayWithDate = weekDaysWithDates.find(day => parseInt(day.id, 10) === dayId);
    const currentDayDate = selectedDayWithDate?.date || null;
    
    // Verificar si estamos en modo de fecha espec√≠fica
    const isSpecificDateMode = selectedDate !== null;
    
    // Determinar la fecha a verificar
    const dateToCheck = isSpecificDateMode && selectedDate 
      ? selectedDate.toISOString().split('T')[0] 
      : currentDayDate;
    
    // Verificar disponibilidad
    const isAvailable = availabilitySettings[dayId]?.includes(hourId);
    
    // Verificar si el slot est√° bloqueado seg√∫n el modo (fecha espec√≠fica o d√≠a recurrente)
    let isBlockedSlot = false;
    if (useSpecificDate && selectedDate) {
      const dateStr = selectedDate.toISOString().split('T')[0];
      isBlockedSlot = isSlotBlocked(null, hourId, dateStr);
    } else {
      isBlockedSlot = isSlotBlocked(dayId, hourId);
    }
    
    // Verificar si hay un evento en esta franja
    const event = events.find(event => 
      new Date(event.fecha).getDay() === dayId && 
      parseInt(event.horaInicio.split(':')[0]) === hourId
    );
    
    // Aplicar estilo directo para slots bloqueados
    const slotStyle = isBlockedSlot 
      ? [
          styles.timeSlot,
          styles.blockedSlot,
          {
            backgroundColor: '#FF3A5E',
            borderColor: '#FF3A5E'
          }
        ] 
      : [
          styles.timeSlot,
          isAvailable ? styles.availableSlot : styles.unavailableSlot,
          event && styles.eventSlot
        ];
    
    // Determinar el estilo del texto
    const textStyle = isBlockedSlot 
      ? [styles.timeText, styles.blockedText] 
      : [styles.timeText, isAvailable ? styles.availableText : styles.unavailableText];
    
    return (
      <TouchableOpacity
        style={slotStyle}
        onPress={() => {
          setSelectedTimeSlot(slot);
          if (isBlockedSlot) {
            // Si est√° bloqueada, mostrar modal para desbloquear
            console.log('Mostrando modal para desbloquear');
            setModalMode('unblock');
            setModalVisible(true);
          } else if (event) {
            // Si hay un evento, mostrar detalles del evento
            console.log('Mostrando modal de informaci√≥n de evento');
            setModalMode('info');
            setModalVisible(true);
          } else {
            // Si est√° disponible pero no tiene evento, mostrar opciones para bloquear
            console.log('Mostrando modal para bloquear');
            setModalMode('block');
            setModalVisible(true);
          }
        }}
      >
        <Text style={textStyle}>
          {`${slot.hour}:00 ${slot.period}`}
        </Text>
        {event && (
          <Text style={styles.eventText} numberOfLines={1}>
            {event.titulo}
          </Text>
        )}
        {isBlockedSlot && (
          <Text style={styles.blockedText}>Bloqueado</Text>
        )}
      </TouchableOpacity>
    );
  };

  const renderModal = () => {
    return (
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            {/* Se elimin√≥ el header del modal */}
            <TouchableOpacity
              style={[styles.closeButton, { position: 'absolute', top: 10, right: 10, zIndex: 10 }]}
              onPress={() => setModalVisible(false)}
            >
              <Ionicons name="close" size={24} color="#FFF" />
            </TouchableOpacity>
            <View style={styles.modalBody}>
              {(modalMode === 'block' || modalMode === 'unblock') && (
                <View>
                  {modalMode === 'block' && (
                    <View style={styles.datePickerContainer}>
                      <View style={styles.switchContainer}>
                        <Text style={styles.switchLabel}>Usar fecha espec√≠fica</Text>
                        <Switch
                          value={useSpecificDate}
                          onValueChange={(value) => {
                            setUseSpecificDate(value);
                            if (value) {
                              setIsRecurring(false); // No puede ser recurrente si es fecha espec√≠fica
                            }
                          }}
                          trackColor={{ false: '#ccc', true: '#4A90E2' }}
                          thumbColor={useSpecificDate ? '#FFFFFF' : '#f4f3f4'}
                        />
                      </View>
                      
                      {useSpecificDate && (
                        <View style={styles.datePickerWrapper}>
                          <TouchableOpacity
                            style={styles.datePickerButton}
                            onPress={() => setShowDatePicker(true)}
                          >
                            <Text style={styles.datePickerButtonText}>
                              Seleccionar fecha: {selectedDate.toLocaleDateString()}
                            </Text>
                            <Ionicons name="calendar" size={20} color="#FFF" />
                          </TouchableOpacity>
                          
                          {showDatePicker && (
                            <View>
                              {Platform.OS === 'ios' ? (
                                <DatePickerIOS
                                  date={selectedDate}
                                  onDateChange={setSelectedDate}
                                  mode="date"
                                  style={{ height: 200, marginTop: 10 }}
                                />
                              ) : (
                                <DateTimePicker
                                  value={selectedDate}
                                  mode="date"
                                  display="default"
                                  onChange={(event, date) => {
                                    setShowDatePicker(false);
                                    if (date) {
                                      setSelectedDate(date);
                                    }
                                  }}
                                />
                              )}
                              
                              {Platform.OS === 'ios' && (
                                <TouchableOpacity
                                  style={[styles.modalButton, { backgroundColor: '#4A90E2', marginTop: 10 }]}
                                  onPress={() => setShowDatePicker(false)}
                                >
                                  <Text style={styles.modalButtonText}>Confirmar fecha</Text>
                                </TouchableOpacity>
                              )}
                            </View>
                          )}
                        </View>
                      )}
                    </View>
                  )}
                  
                  <Text style={styles.modalLabel}>Selecciona una franja horaria:</Text>
                  <ScrollView style={{ maxHeight: 300 }}>
                    {timeSlots.map(slot => {
                      // Asegurarnos de que los IDs sean n√∫meros para comparaci√≥n consistente
                      const dayId = selectedDay ? parseInt(selectedDay.id, 10) : null;
                      const hourId = parseInt(slot.id, 10);
                      
                      // Verificar si el slot est√° bloqueado seg√∫n el modo (fecha espec√≠fica o d√≠a recurrente)
                      let isBlockedSlot = false;
                      if (useSpecificDate && selectedDate) {
                        const dateStr = selectedDate.toISOString().split('T')[0];
                        isBlockedSlot = isSlotBlocked(null, hourId, dateStr);
                      } else {
                        isBlockedSlot = isSlotBlocked(dayId, hourId);
                      }
                      
                      // Solo mostrar para desbloquear si est√° bloqueado
                      if (modalMode === 'unblock' && !isBlockedSlot) return null;
                      
                      // Solo mostrar para bloquear si no est√° bloqueado
                      if (modalMode === 'block' && isBlockedSlot) return null;
                      
                      return (
                        <TouchableOpacity
                          key={`slot-${slot.id}`}
                          style={[
                            styles.timeSlotItem,
                            selectedTimeSlot?.id === slot.id && styles.selectedTimeSlotItem
                          ]}
                          onPress={() => setSelectedTimeSlot(slot)}
                        >
                          <Text style={styles.timeSlotText}>
                            {`${slot.hour}:00 ${slot.period}`}
                          </Text>
                          {selectedTimeSlot?.id === slot.id && (
                            <Ionicons name="checkmark" size={20} color="#4A90E2" />
                          )}
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  
                  {modalMode === 'block' && !useSpecificDate && (
                    <View style={styles.switchContainer}>
                      <Text style={styles.switchLabel}>¬øRepetir semanalmente?</Text>
                      <Switch
                        value={isRecurring}
                        onValueChange={setIsRecurring}
                        trackColor={{ false: '#ccc', true: '#4A90E2' }}
                        thumbColor={isRecurring ? '#FFFFFF' : '#f4f3f4'}
                      />
                    </View>
                  )}
                </View>
              )}
              
              {modalMode === 'info' && selectedTimeSlot && (
                <View style={styles.eventInfoContainer}>
                  {events.find(event => 
                    new Date(event.fecha).getDay() === selectedDay?.id && 
                    parseInt(event.horaInicio.split(':')[0]) === selectedTimeSlot?.id
                  ) ? (
                    <View>
                      <Text style={styles.eventTitle}>
                        {events.find(event => 
                          new Date(event.fecha).getDay() === selectedDay?.id && 
                          parseInt(event.horaInicio.split(':')[0]) === selectedTimeSlot?.id
                        )?.titulo || 'Evento'}
                      </Text>
                      <Text style={styles.eventDescription}>
                        {events.find(event => 
                          new Date(event.fecha).getDay() === selectedDay?.id && 
                          parseInt(event.horaInicio.split(':')[0]) === selectedTimeSlot?.id
                        )?.descripcion || 'Sin descripci√≥n'}
                      </Text>
                    </View>
                  ) : (
                    <Text style={styles.noEventText}>No hay eventos en esta franja horaria</Text>
                  )}
                </View>
              )}
              
              {modalMode === 'availability' && (
                <View style={styles.availabilityContainer}>
                  <View style={styles.switchContainer}>
                    <Text style={styles.switchLabel}>Configurar para fecha espec√≠fica</Text>
                    <Switch
                      value={!!configSpecificDate}
                      onValueChange={(value) => {
                        if (value) {
                          setConfigSpecificDate(new Date());
                          setShowConfigDatePicker(true);
                        } else {
                          setConfigSpecificDate(null);
                          // Recargar la configuraci√≥n general
                          loadAvailabilitySettings();
                        }
                      }}
                      trackColor={{ false: '#ccc', true: '#4A90E2' }}
                      thumbColor={configSpecificDate ? '#FFFFFF' : '#f4f3f4'}
                    />
                  </View>
                  
                  {configSpecificDate && (
                    <View style={styles.datePickerWrapper}>
                      <TouchableOpacity
                        style={styles.datePickerButton}
                        onPress={() => setShowConfigDatePicker(true)}
                      >
                        <Text style={styles.datePickerButtonText}>
                          Configurar para: {configSpecificDate.toLocaleDateString()}
                        </Text>
                        <Ionicons name="calendar" size={20} color="#FFF" />
                      </TouchableOpacity>
                      
                      {showConfigDatePicker && (
                        <View>
                          {Platform.OS === 'ios' ? (
                            <DatePickerIOS
                              date={configSpecificDate}
                              onDateChange={setConfigSpecificDate}
                              mode="date"
                              style={{ height: 200, marginTop: 10 }}
                            />
                          ) : (
                            <DateTimePicker
                              value={configSpecificDate}
                              mode="date"
                              display="default"
                              onChange={(event, date) => {
                                setShowConfigDatePicker(false);
                                if (date) {
                                  setConfigSpecificDate(date);
                                }
                              }}
                            />
                          )}
                          
                          {Platform.OS === 'ios' && (
                            <TouchableOpacity
                              style={[styles.modalButton, { backgroundColor: '#4A90E2', marginTop: 10 }]}
                              onPress={() => setShowConfigDatePicker(false)}
                            >
                              <Text style={styles.modalButtonText}>Confirmar fecha</Text>
                            </TouchableOpacity>
                          )}
                        </View>
                      )}
                    </View>
                  )}
                  
                  <Text style={styles.availabilityText}>
                    Configure los horarios disponibles para {configSpecificDate ? 'esta fecha' : 'este d√≠a'}:
                  </Text>
                  <ScrollView style={{ maxHeight: 350 }}>
                    {timeSlots.map(slot => (
                      <TouchableOpacity
                        key={`avail-${slot.id}`}
                        style={[
                          styles.availabilityItem,
                          availabilitySettings[selectedDay?.id]?.includes(slot.id) ? 
                            styles.availableItem : styles.unavailableItem
                        ]}
                        onPress={() => updateAvailability(
                          selectedDay, 
                          slot, 
                          !availabilitySettings[selectedDay?.id]?.includes(slot.id)
                        )}
                      >
                        <Text style={styles.availabilityItemText}>
                          {`${slot.hour}:00 ${slot.period}`}
                        </Text>
                        <Ionicons 
                          name={availabilitySettings[selectedDay?.id]?.includes(slot.id) ? 
                            "checkmark-circle" : "close-circle"} 
                          size={24} 
                          color={availabilitySettings[selectedDay?.id]?.includes(slot.id) ? 
                            "#4CAF50" : "#FF5252"} 
                        />
                      </TouchableOpacity>
                    ))}
                    <View style={{ height: 80 }} />
                  </ScrollView>
                </View>
              )}
            </View>
            
            <View style={styles.modalFooter}>
              {modalMode === 'block' && (
                <TouchableOpacity 
                  style={[styles.modalButton, styles.blockButton]}
                  onPress={handleBlockSlot}
                >
                  <Text style={styles.modalButtonText}>Bloquear Horario</Text>
                </TouchableOpacity>
              )}
              
              {modalMode === 'unblock' && (
                <TouchableOpacity 
                  style={[styles.modalButton, styles.unblockButton]}
                  onPress={executeUnblock}
                >
                  <Text style={styles.modalButtonText}>Desbloquear Horario</Text>
                </TouchableOpacity>
              )}
              
              {modalMode === 'availability' && (
                <TouchableOpacity 
                  style={[styles.modalButton, { backgroundColor: '#FF3A5E' }]}
                  onPress={handleUpdateAvailability}
                >
                  <Text style={styles.modalButtonText}>
                    {configSpecificDate ? 'Guardar para fecha espec√≠fica' : 'Guardar configuraci√≥n'}
                  </Text>
                </TouchableOpacity>
              )}
              
              <TouchableOpacity 
                style={[styles.modalButton, { backgroundColor: '#333' }]}
                onPress={() => setModalVisible(false)}
              >
                <Text style={styles.modalButtonText}>Cancelar</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  const renderTimeSlots = () => {
    // En lugar de usar FlatList (que es una lista virtualizada) dentro de un ScrollView,
    // simplemente mapeamos los timeSlots directamente
    return (
      <View style={styles.timeSlotsContainer}>
        {timeSlots.map(slot => renderTimeSlot({ item: slot }))}
      </View>
    );
  };

  // Funci√≥n auxiliar para obtener el nombre del d√≠a a partir de su ID
  const getDayName = (dayId) => {
    const days = [
      'Lunes', 
      'Martes', 
      'Mi√©rcoles', 
      'Jueves', 
      'Viernes', 
      'S√°bado', 
      'Domingo'
    ];
    // Ajustar el √≠ndice ya que nuestro array empieza en 0 pero los d√≠as empiezan en 1
    const index = ((dayId - 1) % 7 + 7) % 7; // Asegura un √≠ndice v√°lido incluso con n√∫meros negativos
    return days[index];
  };

  const updateAvailability = (day, slot, isAvailable) => {
    const currentSettings = { ...availabilitySettings };
    
    // Asegurarnos de que el ID del d√≠a sea un n√∫mero v√°lido
    const dayId = parseInt(day.id, 10);
    if (isNaN(dayId)) {
      console.error('ID de d√≠a inv√°lido:', day.id);
      return;
    }
    
    // Asegurarnos de que el ID del slot sea un n√∫mero v√°lido
    const slotId = parseInt(slot.id, 10);
    if (isNaN(slotId)) {
      console.error('ID de slot inv√°lido:', slot.id);
      return;
    }
    
    // Inicializar el array para este d√≠a si no existe
    if (!currentSettings[dayId]) {
      currentSettings[dayId] = [];
    }
    
    if (isAvailable) {
      // Si estamos marcando como disponible, a√±adir a la lista
      if (!currentSettings[dayId].includes(slotId)) {
        currentSettings[dayId].push(slotId);
        // Ordenar el array para mantener el orden de las horas
        currentSettings[dayId].sort((a, b) => a - b);
      }
    } else {
      // Si estamos marcando como no disponible, quitar de la lista
      currentSettings[dayId] = currentSettings[dayId].filter(id => id !== slotId);
    }
    
    setAvailabilitySettings(currentSettings);
  };

  const handleResetBlockedSlots = async () => {
    // Mostrar confirmaci√≥n antes de eliminar todos los slots bloqueados
    Alert.alert(
      'Confirmar Acci√≥n',
      '¬øEst√°s seguro de que deseas eliminar todas las franjas bloqueadas y restablecer la disponibilidad?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Confirmar',
          style: 'destructive',
          onPress: async () => {
            try {
              // Obtener el ID del manager
              const managerId = getValidManagerId();
              if (!managerId) {
                Alert.alert('Error', 'ID de manager inv√°lido');
                return;
              }
              
              // Mostrar mensaje de carga
              Alert.alert('Procesando', 'Restableciendo disponibilidad...');
              
              // 1. Eliminar slots bloqueados locales
              await AsyncStorage.removeItem(`blockedSlots_${managerId}`);
              
              // 2. Intentar eliminar slots del servidor
              try {
                const response = await axios.post(`${BACKEND_URL}/api/spaces/reset-configuration/${managerId}`);
                console.log('Respuesta del servidor al restablecer slots:', response.data);
              } catch (serverError) {
                console.error('Error al restablecer slots en el servidor:', serverError);
                // Continuar con el proceso local incluso si hay error en el servidor
              }
              
              // 3. Limpiar el estado local
              setBlockedSlots([]);
              
              // 4. Mostrar mensaje de √©xito
              Alert.alert(
                '√âxito',
                'Se ha restablecido la disponibilidad correctamente.',
                [{ text: 'OK' }]
              );
              
              // 5. Recargar los datos
              await loadBlockedSlots();
              
            } catch (error) {
              console.error('Error al restablecer disponibilidad:', error);
              Alert.alert('Error', 'No se pudo restablecer la disponibilidad. Int√©ntalo de nuevo.');
            }
          }
        }
      ]
    );
  };

  // Funci√≥n para verificar la conexi√≥n con el servidor
  const checkServerConnection = async () => {
    try {
      const response = await axios.get(`${BACKEND_URL}/api/health`, { timeout: 5000 });
      return response.status === 200;
    } catch (error) {
      console.log('Error al verificar conexi√≥n con el servidor:', error.message);
      return false;
    }
  };

  const loadAvailabilityWithRetry = async (retries = 3) => {
    const isConfiguringSpecificDate = modalVisible && modalMode === 'availability' && configSpecificDate;
    
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        if (!isConfiguringSpecificDate) {
          setIsLoading(true);
        }
        
        // Asegurarnos que managerId sea un n√∫mero v√°lido
        const managerId = getValidManagerId();
        if (!managerId) {
          console.log('No se pudo cargar disponibilidad: ID de manager inv√°lido');
          initializeDefaultAvailability();
          setIsLoading(false);
          return;
        }
        
        // Intentar cargar desde AsyncStorage primero para mostrar algo inmediatamente
        const key = `availability_${managerId}`;
        const storedSettings = await AsyncStorage.getItem(key);
        if (storedSettings) {
          setAvailabilitySettings(JSON.parse(storedSettings));
        } else {
          initializeDefaultAvailability();
        }
        
        // Construir la URL base
        let url = `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`;
        
        // Si hay una fecha espec√≠fica configurada, a√±adirla como par√°metro de consulta
        let dateParam = '';
        if (configSpecificDate) {
          dateParam = configSpecificDate.toISOString().split('T')[0];
          url += `?date=${dateParam}`;
          console.log(`Cargando disponibilidad para fecha espec√≠fica: ${dateParam}`);
        }
        
        console.log(`Intento ${attempt}/${retries}: Solicitando disponibilidad desde URL:`, url);
        
        // Mostrar informaci√≥n detallada sobre los datos que se enviar√°n
        const diasConfig = Object.keys(availabilitySettings).length;
        console.log(`Configurando ${diasConfig} d√≠as${configSpecificDate ? ` para fecha espec√≠fica: ${configSpecificDate.toLocaleDateString()}` : ' (configuraci√≥n general)'}`);
        
        // Preparar datos para enviar al backend
        const requestData = {
          availability: availabilitySettings
        };
        
        // Si estamos configurando para una fecha espec√≠fica, incluirla
        if (configSpecificDate) {
          requestData.date = configSpecificDate.toISOString().split('T')[0];
          console.log(`Configurando disponibilidad para fecha espec√≠fica: ${requestData.date}`);
        }
        
        // Enviar la configuraci√≥n limpia al backend con timeout
        console.log('Enviando datos al servidor:', JSON.stringify(requestData));
        const response = await axios.get(url, { timeout: 10000 }); // Timeout de 10 segundos
        
        if (!isConfiguringSpecificDate) {
          setIsLoading(false);
        }
        
        console.log('Respuesta recibida:', response.status);
        
        if (response.data && response.data.success) {
          console.log('Datos de disponibilidad recibidos:', {
            d√≠as: Object.keys(response.data.availability).length,
            fecha: response.data.date,
            esEspec√≠fica: response.data.isSpecificDate,
            puedeCrearConfig: response.data.canCreateConfig
          });
          
          // Verificar si hay datos de disponibilidad
          if (Object.keys(response.data.availability).length > 0) {
            setAvailabilitySettings(response.data.availability);
            saveAvailabilityToStorage(response.data.availability);
            
            // Mostrar mensaje seg√∫n el tipo de configuraci√≥n
            if (configSpecificDate && !isConfiguringSpecificDate) {
              if (response.data.isSpecificDate) {
                console.log('Usando configuraci√≥n espec√≠fica para la fecha seleccionada');
                // No mostrar alerta para no interrumpir la experiencia del usuario
              } else {
                console.log('Usando configuraci√≥n recurrente (no hay configuraci√≥n espec√≠fica para esta fecha)');
                if (showNotifications && response.data.canCreateConfig) {
                  Alert.alert(
                    'Configuraci√≥n para fecha espec√≠fica',
                    `No hay configuraci√≥n espec√≠fica para ${configSpecificDate.toLocaleDateString()}. ¬øDeseas crear una?`,
                    [
                      { text: 'No', style: 'cancel' },
                      { 
                        text: 'S√≠, configurar', 
                        onPress: () => {
                          // Inicializar con la configuraci√≥n general actual como base
                          const currentConfig = {...availabilitySettings};
                          setAvailabilitySettings(currentConfig);
                          
                          // Detener cualquier proceso de carga en curso
                          setIsLoading(false);
                          
                          // Guardar la fecha espec√≠fica en una variable local
                          const dateToUse = new Date(configSpecificDate);
                          
                          // Usar setTimeout para asegurar que el modal se abra despu√©s de que
                          // se haya cerrado el di√°logo de alerta
                          setTimeout(() => {
                            console.log('Abriendo modal de configuraci√≥n para fecha espec√≠fica:', dateToUse.toLocaleDateString());
                            setConfigSpecificDate(dateToUse);
                            setModalMode('availability');
                            setModalVisible(true);
                            setUseSpecificDate(true);
                          }, 500);
                        },
                        style: 'default'
                      }
                    ]
                  );
                } else if (showNotifications) {
                  Alert.alert('Informaci√≥n', `No hay configuraci√≥n espec√≠fica para ${configSpecificDate.toLocaleDateString()}, mostrando configuraci√≥n general`);
                }
              }
            }
          } else {
            console.log('No se encontraron datos de disponibilidad');
            if (configSpecificDate && showNotifications && !isConfiguringSpecificDate) {
              if (response.data.canCreateConfig) {
                Alert.alert(
                  'Sin configuraci√≥n',
                  `No hay configuraci√≥n para ${configSpecificDate.toLocaleDateString()}. ¬øDeseas crear una configuraci√≥n espec√≠fica para esta fecha?`,
                  [
                    {
                      text: 'No',
                      style: 'cancel',
                      onPress: () => {
                        // Volver a cargar la configuraci√≥n general
                        setUseSpecificDate(false);
                        setConfigSpecificDate(null);
                        loadAvailabilitySettings();
                      }
                    },
                    {
                      text: 'S√≠, configurar',
                      onPress: () => {
                        // Configurar para fecha espec√≠fica
                        setUseSpecificDate(true);
                        setConfigSpecificDate(date);
                        
                        // Abrir el modal para configurar
                        setModalMode('availability');
                        setModalVisible(true);
                      }
                    }
                  ]
                );
              } else {
                Alert.alert('Informaci√≥n', `No hay configuraci√≥n para ${configSpecificDate.toLocaleDateString()}`);
              }
            }
          }
          
          // Si llegamos aqu√≠, la carga fue exitosa
          return;
        } else {
          console.log('Error en la respuesta:', response.data);
          if (attempt === retries && showNotifications) {
            Alert.alert('Error', 'No se pudo cargar la disponibilidad desde el servidor');
          }
        }
      } catch (error) {
        if (!isConfiguringSpecificDate) {
          setIsLoading(false);
        }
        
        console.log(`Intento ${attempt}/${retries} - Error al cargar disponibilidad:`, error.message);
        
        if (error.code === 'ECONNABORTED') {
          console.log('Timeout al conectar con el servidor');
        }
        
        // Si es el √∫ltimo intento, mostrar mensaje de error
        if (attempt === retries) {
          console.log('Detalles del error:', error.response ? error.response.data : 'No hay detalles adicionales');
          
          // Verificar si el servidor est√° disponible
          const isServerAvailable = await checkServerConnection();
          
          if (!isServerAvailable && showNotifications) {
            Alert.alert(
              'Error de conexi√≥n', 
              'No se pudo conectar con el servidor. Verifica tu conexi√≥n a internet y que el servidor est√© en funcionamiento.',
              [
                { text: 'OK' },
                { 
                  text: 'Reintentar', 
                  onPress: () => loadAvailabilityWithRetry(3) 
                }
              ]
            );
          } else if (showNotifications) {
            Alert.alert('Error', 'No se pudo cargar la disponibilidad. Usando configuraci√≥n guardada localmente.');
          }
        } else {
          // Esperar antes del siguiente intento (tiempo exponencial)
          const waitTime = Math.pow(2, attempt) * 1000;
          console.log(`Esperando ${waitTime}ms antes del siguiente intento...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
      }
    }
  };

  const handleUnblockSlot = async (day, hour, blockedSlot = null) => {
    try {
      setIsLoading(true);
      
      const managerId = getValidManagerId();
      if (!managerId) {
        Alert.alert('Error', 'ID de manager inv√°lido');
        setIsLoading(false);
        return;
      }
      
      // Validar que tengamos valores v√°lidos
      if ((day === undefined || hour === undefined) && !blockedSlot) {
        console.error('Valores faltantes para desbloquear slot:', { day, hour, blockedSlot });
        Alert.alert('Error', 'Informaci√≥n incompleta para desbloquear el horario');
        setIsLoading(false);
        return;
      }
      
      console.log(`Intentando desbloquear slot:`, { day, hour, blockedSlotId: blockedSlot?.id });
      
      let response;
      
      // Si tenemos el ID del slot bloqueado, usar ese endpoint
      if (blockedSlot && blockedSlot.id) {
        console.log(`Desbloqueando por ID: ${blockedSlot.id}`);
        response = await axios.post(`${BACKEND_URL}/api/spaces/unblock-slot-by-id/${blockedSlot.id}`);
      } else {
        // Si no tenemos el ID, usar el endpoint que requiere d√≠a y hora
        // Asegurarnos de que day y hour sean n√∫meros
        const dayNum = typeof day === 'string' ? parseInt(day, 10) : day;
        const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
        
        if (isNaN(dayNum) || isNaN(hourNum)) {
          console.error('Valores inv√°lidos para desbloquear slot:', { day, hour, dayNum, hourNum });
          Alert.alert('Error', 'Valores inv√°lidos para desbloquear el horario');
          setIsLoading(false);
          return;
        }
        
        console.log(`Desbloqueando por d√≠a/hora: ${dayNum}/${hourNum}`);
        
        // Crear un objeto limpio sin referencias circulares
        const requestData = {
          day: dayNum,
          hour: hourNum
        };
        
        // Si hay una fecha espec√≠fica seleccionada, incluirla
        if (selectedDate) {
          requestData.date = selectedDate.toISOString().split('T')[0];
        } else if (configSpecificDate) {
          requestData.date = configSpecificDate.toISOString().split('T')[0];
        }
        
        console.log('Datos de desbloqueo:', JSON.stringify(requestData));
        
        // Asegurarnos de que la URL sea correcta
        const url = `${BACKEND_URL}/api/spaces/unblock-slot/${managerId}`;
        console.log('URL de desbloqueo:', url);
        
        response = await axios.post(url, requestData);
      }
      
      setIsLoading(false);
      
      if (response.data && response.data.success) {
        // Actualizar inmediatamente el estado local de slots bloqueados
        // Esto es crucial para que la interfaz se actualice sin tener que recargar
        if (blockedSlot && blockedSlot.id) {
          // Si tenemos el ID del slot, eliminarlo del array de slots bloqueados
          setBlockedSlots(prevSlots => prevSlots.filter(slot => slot.id !== blockedSlot.id));
        } else {
          // Si no tenemos el ID, eliminar por d√≠a y hora
          const dayNum = typeof day === 'string' ? parseInt(day, 10) : day;
          const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
          
          setBlockedSlots(prevSlots => {
            return prevSlots.filter(slot => {
              // Si hay fecha espec√≠fica, filtrar por fecha tambi√©n
              if (selectedDate || configSpecificDate) {
                const dateToCheck = selectedDate ? selectedDate : configSpecificDate;
                const dateStr = dateToCheck.toISOString().split('T')[0];
                return !(slot.day === dayNum && slot.hour === hourNum && slot.date === dateStr);
              }
              // Si no hay fecha espec√≠fica, filtrar solo por d√≠a y hora
              return !(slot.day === dayNum && slot.hour === hourNum);
            });
          });
        }
        
        Alert.alert('√âxito', 'Horario desbloqueado correctamente');
        
        // Recargar los slots bloqueados desde el servidor para asegurar sincronizaci√≥n
        loadBlockedSlots();
        
        // Cerrar el modal
        setModalVisible(false);
      } else {
        Alert.alert('Error', 'No se pudo desbloquear el horario: ' + (response.data?.message || 'Error desconocido'));
      }
    } catch (error) {
      console.error('Error al desbloquear slot:', error);
      console.error('Detalles del error:', error.response ? error.response.data : 'No hay detalles adicionales');
      console.error('C√≥digo de estado:', error.response ? error.response.status : 'Desconocido');
      
      setIsLoading(false);
      
      // Mensaje m√°s espec√≠fico seg√∫n el c√≥digo de error
      let errorMessage = 'Error al desbloquear el horario';
      
      if (error.response) {
        if (error.response.status === 400) {
          errorMessage = 'Datos inv√°lidos para desbloquear el horario. Verifica que los valores sean correctos.';
        } else if (error.response.status === 404) {
          errorMessage = 'No se encontr√≥ el slot para desbloquear.';
        } else if (error.response.status === 500) {
          errorMessage = 'Error interno del servidor al desbloquear el horario.';
        }
        
        // Incluir mensaje del servidor si est√° disponible
        if (error.response.data && error.response.data.message) {
          errorMessage += ` Mensaje del servidor: ${error.response.data.message}`;
        }
      }
      
      Alert.alert('Error', errorMessage);
    }
  };

  const showUnblockModal = (day, slot, blockedSlot = null) => {
    // Guardar el d√≠a y slot seleccionados
    setSelectedDay(day);
    setSelectedTimeSlot(slot);
    
    // Configurar el modal para desbloqueo
    setModalMode('unblock');
    setModalVisible(true);
    
    // Guardar el slot bloqueado si se proporciona
    setSelectedBlockedSlot(blockedSlot);
  };

  const executeUnblock = () => {
    // Verificar que tengamos los datos necesarios
    if (!selectedDay || !selectedTimeSlot) {
      Alert.alert('Error', 'Debes seleccionar un d√≠a y una hora');
      return;
    }
    
    // Llamar a la funci√≥n de desbloqueo con los valores seleccionados
    handleUnblockSlot(selectedDay.id, selectedTimeSlot.id, selectedBlockedSlot);
  };

  const handleBlockSlot = async () => {
    try {
      setIsLoading(true);
      
      const managerId = getValidManagerId();
      if (!managerId) {
        Alert.alert('Error', 'ID de manager inv√°lido');
        setIsLoading(false);
        return;
      }
      
      // Verificar que se haya seleccionado un d√≠a y hora
      if (!selectedDay || !selectedTimeSlot) {
        Alert.alert('Error', 'Debes seleccionar un d√≠a y una hora');
        setIsLoading(false);
        return;
      }
      
      // Preparar datos para la solicitud
      const requestData = {
        day: selectedDay.id,
        hour: selectedTimeSlot.id,
        reason: 'No disponible'
      };
      
      // Si hay una fecha espec√≠fica seleccionada, incluirla
      if (selectedDate) {
        const dateString = selectedDate.toISOString().split('T')[0];
        requestData.date = dateString;
      }
      
      console.log(`Enviando solicitud al servidor: ${BACKEND_URL}/api/spaces/block-slot/${managerId}`);
      console.log('Datos:', JSON.stringify(requestData));
      
      const response = await axios.post(`${BACKEND_URL}/api/spaces/block-slot/${managerId}`, requestData);
      
      setIsLoading(false);
      
      if (response.data && response.data.success) {
        Alert.alert('√âxito', 'Horario bloqueado correctamente');
        // Recargar los slots bloqueados
        loadBlockedSlots();
        // Cerrar el modal
        setModalVisible(false);
      } else {
        Alert.alert('Error', 'No se pudo bloquear el horario: ' + (response.data?.message || 'Error desconocido'));
      }
    } catch (error) {
      console.error('Error al bloquear slot:', error);
      setIsLoading(false);
      Alert.alert('Error', 'Error al bloquear el horario: ' + error.message);
    }
  };

  const handleSpecificDateChange = (date) => {
    console.log(`Cambiando fecha espec√≠fica a: ${date.toLocaleDateString()}`);
    // Cerrar el selector de fecha
    setShowConfigDatePicker(false);
    // Actualizar la fecha espec√≠fica sin desencadenar una carga inmediata
    setConfigSpecificDate(date);
  };

  const openAvailabilityModal = (date = null) => {
    // Si se proporciona una fecha, configurarla
    if (date) {
      setConfigSpecificDate(date);
    }
    
    // Configurar el modo del modal
    setModalMode('availability');
    
    // Mostrar el modal
    setModalVisible(true);
  };

  const loadSpecificDateAvailability = (date) => {
    if (!date) return;
    
    // Evitar ciclos de carga
    if (isLoading) return;
    
    console.log(`Cargando disponibilidad para fecha espec√≠fica: ${date.toLocaleDateString()}`);
    
    // Primero cargar la configuraci√≥n general como base
    const managerId = getValidManagerId();
    if (!managerId) return;
    
    // Mostrar indicador de carga
    setIsLoading(true);
    
    // Cargar primero la configuraci√≥n general como base
    axios.get(`${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`)
      .then(generalResponse => {
        if (generalResponse.data && generalResponse.data.success) {
          // Guardar la configuraci√≥n general como base
          const generalSettings = generalResponse.data.availability;
          console.log('Configuraci√≥n general cargada como base:', generalSettings);
          
          // Ahora cargar la configuraci√≥n espec√≠fica
          const dateString = date.toISOString().split('T')[0];
          axios.get(`${BACKEND_URL}/api/cultural-spaces/availability/${managerId}?date=${dateString}`)
            .then(specificResponse => {
              setIsLoading(false);
              
              if (specificResponse.data && specificResponse.data.success) {
                const specificSettings = specificResponse.data.availability;
                
                // Si hay configuraci√≥n espec√≠fica, combinarla con la general
                if (Object.keys(specificSettings).length > 0) {
                  console.log('Configuraci√≥n espec√≠fica encontrada:', specificSettings);
                  
                  // Combinar configuraci√≥n general con espec√≠fica
                  const combinedSettings = { ...generalSettings };
                  
                  // Sobrescribir solo los d√≠as que tienen configuraci√≥n espec√≠fica
                  for (const day in specificSettings) {
                    combinedSettings[day] = specificSettings[day];
                  }
                  
                  setAvailabilitySettings(combinedSettings);
                  console.log('Configuraci√≥n combinada:', combinedSettings);
                } else if (specificResponse.data.canCreateConfig) {
                  // Si no hay configuraci√≥n espec√≠fica pero se puede crear, usar la general como base
                  setAvailabilitySettings(generalSettings);
                  console.log('No hay configuraci√≥n espec√≠fica, usando general como base');
                  
                  // Preguntar si quiere crear configuraci√≥n espec√≠fica
                  if (!isConfiguringSpecificDate && !modalVisible) {
                    Alert.alert(
                      'Configuraci√≥n no encontrada',
                      `No hay configuraci√≥n espec√≠fica para ${date.toLocaleDateString()}. ¬øDeseas crear una?`,
                      [
                        {
                          text: 'No',
                          style: 'cancel',
                          onPress: () => {
                            // Volver a cargar la configuraci√≥n general
                            setUseSpecificDate(false);
                            setConfigSpecificDate(null);
                            loadAvailabilitySettings();
                          }
                        },
                        {
                          text: 'S√≠, configurar',
                          onPress: () => {
                            // Configurar para fecha espec√≠fica
                            setUseSpecificDate(true);
                            setConfigSpecificDate(date);
                            
                            // Abrir el modal para configurar
                            setModalMode('availability');
                            setModalVisible(true);
                          }
                        }
                      ]
                    );
                  }
                  return;
                }
              } else {
                console.error('Error al cargar configuraci√≥n espec√≠fica:', specificResponse.data?.message);
                setAvailabilitySettings(generalSettings);
              }
            })
            .catch(error => {
              console.error('Error al cargar configuraci√≥n espec√≠fica:', error);
              setIsLoading(false);
              setAvailabilitySettings(generalSettings);
            });
        } else {
          console.error('Error al cargar configuraci√≥n general:', generalResponse.data?.message);
          setIsLoading(false);
        }
      })
      .catch(error => {
        console.error('Error al cargar configuraci√≥n general:', error);
        setIsLoading(false);
      });
  };

  const handleUpdateAvailability = async () => {
    console.log('Iniciando guardado de disponibilidad...');
    
    // Mostrar indicador de carga
    setIsLoading(true);
    
    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        Alert.alert('Error', 'ID de manager inv√°lido');
        setIsLoading(false);
        return;
      }
      
      console.log('Manager ID v√°lido:', managerId);
      
      // Asegurarnos de que todos los valores sean n√∫meros v√°lidos
      let cleanedSettings = {};
      
      // Si estamos configurando para una fecha espec√≠fica, solo incluir el d√≠a de esa fecha
      if (configSpecificDate) {
        // Obtener el d√≠a de la semana (0-6, donde 0 es domingo)
        const dayOfWeek = configSpecificDate.getDay();
        const adjustedDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek; // Convertir domingo (0) a 7
        
        console.log(`Configurando solo para el d√≠a ${adjustedDayOfWeek} (${getDayName(adjustedDayOfWeek)})`);
        
        // Solo incluir el d√≠a espec√≠fico si tiene horas configuradas
        if (availabilitySettings[adjustedDayOfWeek] && availabilitySettings[adjustedDayOfWeek].length > 0) {
          // Filtrar y convertir las horas a n√∫meros enteros
          const validHours = availabilitySettings[adjustedDayOfWeek]
            .filter(hourId => !isNaN(parseInt(hourId, 10)))
            .map(hourId => parseInt(hourId, 10));
          
          if (validHours.length > 0) {
            cleanedSettings[adjustedDayOfWeek] = validHours;
            console.log(`D√≠a ${adjustedDayOfWeek}: ${validHours.length} horas configuradas para fecha espec√≠fica`);
          }
        }
      } else {
        // Para configuraci√≥n general, procesar cada d√≠a y sus horas disponibles
        for (const dayId in availabilitySettings) {
          // Convertir el ID del d√≠a a n√∫mero entero
          const dayKey = parseInt(dayId, 10);
          if (isNaN(dayKey)) continue; // Saltar d√≠as con ID inv√°lido
          
          // Filtrar y convertir las horas a n√∫meros enteros
          const validHours = availabilitySettings[dayId]
            .filter(hourId => !isNaN(parseInt(hourId, 10)))
            .map(hourId => parseInt(hourId, 10));
          
          // Solo agregar d√≠as con horas v√°lidas
          if (validHours.length > 0) {
            cleanedSettings[dayKey] = validHours;
            console.log(`D√≠a ${dayKey}: ${validHours.length} horas configuradas`);
          }
        }
      }
      
      // Preparar datos para enviar al backend
      const requestData = {
        availability: cleanedSettings
      };
      
      // Si estamos configurando para una fecha espec√≠fica, incluirla
      if (configSpecificDate) {
        const dateString = configSpecificDate.toISOString().split('T')[0];
        requestData.date = dateString; // Cambiar specificDate a date para coincidir con el backend
        console.log(`Configurando disponibilidad para fecha espec√≠fica: ${dateString}`);
      } else {
        console.log('Configurando disponibilidad general (sin fecha espec√≠fica)');
      }
      
      // Enviar la configuraci√≥n al backend
      console.log('Enviando datos al servidor:', JSON.stringify(requestData));
      const response = await axios.post(
        `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`, 
        requestData,
        { timeout: 15000 } // 15 segundos de timeout
      );
      
      // Ocultar indicador de carga
      setIsLoading(false);
      
      console.log('Respuesta del servidor:', response.data);
      
      if (response.data && response.data.success) {
        // Actualizar el estado con los datos limpios
        setAvailabilitySettings(cleanedSettings);
        
        // Guardar en local storage
        saveAvailabilityToStorage(cleanedSettings);
        
        // Mensaje espec√≠fico seg√∫n el tipo de configuraci√≥n
        const mensaje = configSpecificDate 
          ? `Configuraci√≥n guardada correctamente para ${configSpecificDate.toLocaleDateString()}`
          : 'Configuraci√≥n guardada correctamente';
          
        Alert.alert('√âxito', mensaje, [
          { 
            text: 'OK', 
            onPress: () => {
              // Cerrar el modal
              setModalVisible(false);
              
              // Recargar la disponibilidad para ver los cambios
              setTimeout(() => loadAvailabilitySettings(), 500);
            } 
          }
        ]);
      } else {
        Alert.alert('Error', 'No se pudo guardar la configuraci√≥n en el servidor: ' + (response.data?.message || 'Error desconocido'));
      }
    } catch (error) {
      console.error('Error al guardar configuraci√≥n:', error.message);
      setIsLoading(false);
      
      // Verificar si el servidor est√° disponible
      try {
        await axios.get(`${BACKEND_URL}/api/health`, { timeout: 5000 });
        Alert.alert('Error', 'Error al guardar la configuraci√≥n: ' + error.message);
      } catch (connectionError) {
        Alert.alert(
          'Error de conexi√≥n', 
          'No se pudo conectar con el servidor. Verifica tu conexi√≥n a internet.',
          [
            { text: 'OK' },
            { 
              text: 'Reintentar', 
              onPress: handleUpdateAvailability,
              style: 'default'
            }
          ]
        );
      }
    }
  };

  const debugBlockedSlots = () => {
    console.log('üîç DEPURACI√ìN DE SLOTS BLOQUEADOS:');
    console.log(`üìã Total de slots bloqueados: ${blockedSlots.length}`);
    
    blockedSlots.forEach((slot, index) => {
      console.log(`üìå Slot ${index + 1}:`);
      console.log(`   ID: ${slot.id}`);
      console.log(`   Fecha: ${slot.date || 'No especificada'}`);
      console.log(`   DateStr: ${slot.dateStr || 'No especificada'}`);
      console.log(`   D√≠a: ${slot.day} (${getDayName(slot.day) || 'No especificado'})`);
      console.log(`   Hora: ${slot.hour}`);
    });
  };

  // Depurar slots bloqueados para una fecha espec√≠fica
  const debugBlockedSlotsForDate = (dateStr) => {
    console.log(`üîç Buscando slots bloqueados para fecha: ${dateStr}`);
    
    const matchingSlots = blockedSlots.filter(slot => {
      const slotDate = slot.dateStr || slot.date;
      
      return slotDate === dateStr;
    });
    
    console.log(`üìã Encontrados ${matchingSlots.length} slots bloqueados para esta fecha:`);
    matchingSlots.forEach((slot, index) => {
      console.log(`   Slot ${index + 1}: hora=${slot.hour}, fecha=${slot.dateStr || slot.date}`);
    });
  };

  const initializeDefaultAvailability = () => {
    // Inicializar la disponibilidad con valores predeterminados (todos los d√≠as, todas las horas disponibles)
    const defaultSettings = {};
    weekDays.forEach(day => {
      defaultSettings[day.id] = timeSlots.map(slot => slot.id);
    });
    setAvailabilitySettings(defaultSettings);
  };

  const handleDaySelect = (day) => {
    console.log(`Seleccionando d√≠a: ${day.name} (${day.date || 'sin fecha'})`);
    
    // Limpiar la fecha espec√≠fica al cambiar de d√≠a
    setSelectedDate(null);
    setUseSpecificDate(false);
    
    // Establecer el d√≠a seleccionado
    setSelectedDay(day);
    
    // Depurar los slots bloqueados para este d√≠a
    if (day.date) {
      debugBlockedSlotsForDate(day.date);
    }
  };

  return (
    <View style={styles.container}>
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#FF3A5E" />
          <Text style={styles.loadingText}>Cargando informaci√≥n...</Text>
        </View>
      ) : (
        <>
          <View style={styles.header}>
            <TouchableOpacity 
              onPress={() => {
                if (onClose && typeof onClose === 'function') {
                  onClose();
                } else {
                  navigation.goBack();
                }
              }} 
              style={styles.backButton}
            >
              <Ionicons name="arrow-back" size={24} color="#FFF" />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>{spaceData?.nombre || 'Gesti√≥n de Horarios'}</Text>
            <View style={styles.headerRight}>
              {/* Se elimin√≥ el icono del calendario */}
            </View>
          </View>
          <ScrollView style={styles.scrollContainer} contentContainerStyle={styles.scrollContentContainer}>
            <View style={styles.contentContainer}>
              <View style={styles.weekDaysContainer}>
                {weekDaysWithDates.map(day => (
                  <TouchableOpacity
                    key={day.id}
                    style={[
                      styles.dayButton,
                      selectedDay?.id === day.id && styles.selectedDayButton
                    ]}
                    onPress={() => handleDaySelect(day)}
                  >
                    <Text style={[
                      styles.dayText,
                      selectedDay?.id === day.id && styles.selectedDayText
                    ]}>
                      {day.shortName}
                    </Text>
                    <Text style={styles.dayDate}>{day.name}</Text>
                    <Text style={styles.dayDate}>{day.displayDate}</Text>
                  </TouchableOpacity>
                ))}
              </View>
              
              {selectedDay && (
                <View style={styles.scheduleContainer}>
                  <View style={styles.scheduleHeader}>
                    <Text style={styles.scheduleDayTitle}>{selectedDay.name}</Text>
                    <View style={styles.scheduleActions}>
                      <TouchableOpacity
                        style={[styles.actionButton, { backgroundColor: '#FF3A5E' }]}
                        onPress={() => {
                          setModalMode('availability');
                          setModalVisible(true);
                        }}
                      >
                        <Ionicons name="time" size={18} color="#FFFFFF" />
                        <Text style={styles.actionButtonText}>Configurar</Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.actionButton, { backgroundColor: '#333' }]}
                        onPress={() => {
                          setModalMode('block');
                          setModalVisible(true);
                        }}
                      >
                        <Ionicons name="lock-closed" size={18} color="#FFFFFF" />
                        <Text style={styles.actionButtonText}>Bloquear</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                  
                  {/* Lista de horarios disponibles */}
                  {renderTimeSlots()}
                </View>
              )}
            </View>
          </ScrollView>
        </>
      )}
      
      {renderModal()}
      <View style={styles.buttonContainer}>
        <TouchableOpacity 
          style={[styles.button, { backgroundColor: '#FF3A5E' }]}
          onPress={handleResetBlockedSlots}
        >
          <Text style={styles.buttonText}>Restablecer Disponibilidad</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 15,
    paddingVertical: 15,
    backgroundColor: '#FF3A5E',
    marginTop: 35,         // Margen superior para respetar la barra de estado
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
    flex: 1,
  },
  closeButton: {
    padding: 5,
  },
  scrollContainer: {
    flex: 1,
  },
  scrollContentContainer: {
    paddingVertical: 20,
  },
  contentContainer: {
    padding: 15,
  },
  weekDaysContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  dayButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#333333',
    justifyContent: 'center',
    alignItems: 'center',
  },
  selectedDayButton: {
    backgroundColor: '#FF3A5E',
  },
  dayText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  selectedDayText: {
    color: '#FFFFFF',
  },
  dayDate: {
    fontSize: 12,
    color: '#FFFFFF',
    textAlign: 'center',
    marginTop: 5,
  },
  scheduleContainer: {
    marginBottom: 20,
  },
  scheduleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  scheduleDayTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  scheduleActions: {
    flexDirection: 'row',
  },
  actionButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 5,
    marginLeft: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButtonText: {
    color: '#FFFFFF',
    marginLeft: 5,
    fontSize: 14,
  },
  timeSlot: {
    padding: 12,
    borderRadius: 8,
    marginBottom: 10,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  availableSlot: {
    backgroundColor: '#1E3A2E',
  },
  unavailableSlot: {
    backgroundColor: '#3A1E1E',
  },
  eventSlot: {
    backgroundColor: '#1E2A3A',
  },
  timeText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  eventText: {
    color: '#4A90E2',
    fontSize: 14,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'right',
    marginRight: 10,
  },
  lockIcon: {
    marginLeft: 5,
  },
  // Estilos para el modal
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    maxHeight: '85%',
    backgroundColor: '#222222',
    borderRadius: 12,
    overflow: 'hidden',
  },
  modalBody: {
    padding: 15,
  },
  modalLabel: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 15,
  },
  timeSlotItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    backgroundColor: '#333333',
  },
  selectedTimeSlotItem: {
    backgroundColor: '#1E3A3A',
    borderWidth: 1,
    borderColor: '#4A90E2',
  },
  timeSlotText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 20,
    marginBottom: 10,
    paddingVertical: 10,
    paddingHorizontal: 10,
    backgroundColor: '#333333',
    borderRadius: 8,
  },
  switchLabel: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  availabilityContainer: {
    marginBottom: 10,
  },
  availabilityText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 15,
  },
  availabilityItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    backgroundColor: '#333333',
  },
  availableItem: {
    backgroundColor: '#1E3A2E',
  },
  unavailableItem: {
    backgroundColor: '#3A1E1E',
  },
  availabilityItemText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  eventInfoContainer: {
    padding: 10,
    backgroundColor: '#1E2A3A',
    borderRadius: 8,
  },
  eventTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  eventDescription: {
    fontSize: 16,
    color: '#CCCCCC',
  },
  noEventText: {
    fontSize: 16,
    color: '#CCCCCC',
    fontStyle: 'italic',
  },
  modalFooter: {
    padding: 15,
    borderTopWidth: 1,
    borderTopColor: '#444444',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  modalButton: {
    flex: 1,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 5,
  },
  blockButton: {
    backgroundColor: '#8C2626',
  },
  unblockButton: {
    backgroundColor: '#267F8C',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#FFFFFF',
    marginTop: 10,
    fontSize: 16,
  },
  buttonContainer: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    right: 20,
  },
  button: {
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  // Estilos adicionales para el selector de fechas
  datePickerContainer: {
    marginBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#444',
    paddingBottom: 15,
  },
  datePickerWrapper: {
    marginTop: 10,
  },
  datePickerButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#333',
    padding: 12,
    borderRadius: 8,
  },
  datePickerButtonText: {
    color: '#FFF',
    fontSize: 16,
  },
});

export default SpaceSchedule;
