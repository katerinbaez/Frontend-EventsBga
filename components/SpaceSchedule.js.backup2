import React, { useState, useEffect, useMemo } from 'react';
import { View, Text, TouchableOpacity, ScrollView, StyleSheet, Alert, ActivityIndicator, Modal, FlatList, Switch, DatePickerIOS, Platform, Button } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { useAuth } from '../context/AuthContext';
import axios from 'axios';
import { BACKEND_URL } from '../constants/config';
import AsyncStorage from '@react-native-async-storage/async-storage';
import DateTimePicker from '@react-native-community/datetimepicker';

const SpaceSchedule = ({ onClose }) => {
  const { user } = useAuth();
  const navigation = useNavigation();
  const [loading, setLoading] = useState(true);
  const [spaceData, setSpaceData] = useState(null);
  const [selectedDay, setSelectedDay] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [events, setEvents] = useState([]);
  const [availabilitySettings, setAvailabilitySettings] = useState({});
  const [blockedSlots, setBlockedSlots] = useState([]);
  const [blockedSlotsByDate, setBlockedSlotsByDate] = useState({});
  const [isRecurring, setIsRecurring] = useState(false);
  const [modalMode, setModalMode] = useState('info'); // 'info', 'block', 'availability'
  const [viewMode, setViewMode] = useState('weekly'); // 'weekly', 'daily'
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [useSpecificDate, setUseSpecificDate] = useState(false);
  const [configSpecificDate, setConfigSpecificDate] = useState(null);
  const [showConfigDatePicker, setShowConfigDatePicker] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [showNotifications, setShowNotifications] = useState(true);
  const [selectedBlockedSlot, setSelectedBlockedSlot] = useState(null);
  const [forceUpdate, setForceUpdate] = useState(0);
  const [weekDaysWithDates, setWeekDaysWithDates] = useState([]);

  // D√≠as de la semana
  const weekDays = [
    { id: 1, name: 'Lunes', shortName: 'Lun' },
    { id: 2, name: 'Martes', shortName: 'Mar' },
    { id: 3, name: 'Mi√©rcoles', shortName: 'Mi√©' },
    { id: 4, name: 'Jueves', shortName: 'Jue' },
    { id: 5, name: 'Viernes', shortName: 'Vie' },
    { id: 6, name: 'S√°bado', shortName: 'S√°b' },
    { id: 0, name: 'Domingo', shortName: 'Dom' }
  ];

  // Franjas horarias (de 6am a 10pm)
  const timeSlots = Array.from({ length: 17 }, (_, index) => {
    const hour = index + 6;
    return { 
      id: hour, 
      hour: hour > 12 ? hour - 12 : hour, 
      period: hour >= 12 ? 'PM' : 'AM' 
    };
  });

  useEffect(() => {
    const loadInitialData = async () => {
      try {
        console.log('Cargando datos iniciales...');
        setLoading(true);
        
        // PASO 1: Inicializar d√≠as de la semana con fechas locales correctas
        const initialWeekDays = initializeWeekDays();
        setWeekDaysWithDates(initialWeekDays);
        console.log('D√≠as de la semana inicializados correctamente');
        
        // PASO 2: Seleccionar el d√≠a actual por defecto usando la fecha local
        const now = new Date();
        const todayDayOfWeek = now.getDay(); // 0 = domingo, 1 = lunes, ..., 6 = s√°bado
        const todayDay = initialWeekDays.find(day => parseInt(day.id, 10) === todayDayOfWeek);
        
        if (todayDay) {
          setSelectedDay(todayDay);
          console.log(`D√≠a seleccionado: ${todayDay.name} (${todayDay.date})`);
          
          // Actualizar la fecha seleccionada con la fecha local correcta
          const [year, month, day] = todayDay.date.split('-').map(num => parseInt(num, 10));
          const dateObj = new Date(year, month - 1, day);
          
          if (!isNaN(dateObj.getTime())) {
            setSelectedDate(dateObj);
            console.log(`Fecha seleccionada establecida: ${dateObj.toLocaleDateString()}`);
          }
        } else {
          setSelectedDay(initialWeekDays[0]);
          console.log(`No se encontr√≥ el d√≠a actual, seleccionando el primer d√≠a: ${initialWeekDays[0].name}`);
        }
        
        // PASO 3: Cargar configuraci√≥n de disponibilidad
        await loadAvailabilitySettings();
        
        // PASO 4: Cargar eventos
        await loadEvents();
        
        // PASO 5: Cargar slots bloqueados despu√©s de que los d√≠as est√©n inicializados
        // Esperamos a que todo est√© listo para garantizar que los slots se asignen correctamente
        await loadBlockedSlots();
        
        // PASO 6: Forzar actualizaci√≥n de la UI para asegurar que todo se muestre correctamente
        setForceUpdate(prev => prev + 1);
        
        console.log('Datos iniciales cargados correctamente');
        setLoading(false);
        
        // PASO 7: Ejecutar depuraci√≥n para verificar que todo est√° correcto
        setTimeout(() => {
          debugWeekDays();
          debugBlockedSlots();
        }, 1000);
      } catch (error) {
        console.error('Error al cargar datos iniciales:', error);
        setLoading(false);
      }
    };
    
    // Cargar datos iniciales al montar el componente
    loadInitialData();
    
    // Configurar sincronizaci√≥n autom√°tica cada 5 minutos
    const syncInterval = setInterval(() => {
      console.log('üîÑ Sincronizaci√≥n autom√°tica iniciada...');
      
      // Actualizar d√≠as de la semana
      const updatedWeekDays = initializeWeekDays();
      setWeekDaysWithDates(updatedWeekDays);
      
      // Recargar slots bloqueados
      loadBlockedSlots().then(() => {
        console.log('‚úÖ Sincronizaci√≥n autom√°tica completada');
        
        // Forzar actualizaci√≥n de la UI
        setForceUpdate(prev => prev + 1);
      }).catch(error => {
        console.error('Error en sincronizaci√≥n autom√°tica:', error);
      });
    }, 5 * 60 * 1000); // 5 minutos en milisegundos
    
    // Limpiar intervalo al desmontar el componente
    return () => {
      clearInterval(syncInterval);
    };
  }, []);

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      if (user && user.id) {
        try {
          // Cargar datos del espacio cultural primero
          await loadSpaceData();
          // Luego cargar el resto de los datos
          await loadEvents();
          await loadAvailabilitySettings();
          await loadBlockedSlots();
          
          // Seleccionar el primer d√≠a por defecto
          if (weekDays.length > 0) {
            setSelectedDay(weekDays[0]);
          }
        } catch (error) {
          console.error('Error al cargar datos:', error);
          initializeDefaultAvailability();
          setBlockedSlots([]);
        }
      } else {
        console.log('Usuario inv√°lido o sin ID, inicializando valores por defecto', user);
        initializeDefaultAvailability();
        setBlockedSlots([]);
      }
      setLoading(false);
    };
    
    loadData();
  }, [user]);
  
  // Efecto adicional para forzar la actualizaci√≥n de la interfaz cuando cambian los slots bloqueados
  useEffect(() => {
    if (blockedSlots.length > 0) {
      console.log(`üîç Se han cargado ${blockedSlots.length} slots bloqueados`);
      debugBlockedSlots();
      
      // Verificar que los slots bloqueados solo aparezcan en su fecha espec√≠fica
      console.log('Verificando que los slots bloqueados solo aparezcan en su fecha espec√≠fica...');
      
      // Recorrer todos los d√≠as de la semana
      weekDaysWithDates.forEach(day => {
        if (day && day.date) {
          // Verificar si hay slots bloqueados para esta fecha
          const slotsForDate = blockedSlotsByDate[day.date] || [];
          if (slotsForDate.length > 0) {
            console.log(`D√≠a ${day.name} (${day.date}): ${slotsForDate.length} slots bloqueados`);
          }
        }
      });
    }
  }, [blockedSlots, blockedSlotsByDate, weekDaysWithDates]);

  useEffect(() => {
    // Solo cargar si configSpecificDate tiene un valor y no estamos en medio de una configuraci√≥n
    if (configSpecificDate && !modalVisible && !isLoading) {
      // Usar un timeout para evitar m√∫ltiples actualizaciones en el mismo ciclo
      const timer = setTimeout(() => {
        loadSpecificDateAvailability(configSpecificDate);
      }, 300);
      
      return () => clearTimeout(timer);
    }
  }, [configSpecificDate, modalVisible]);

  // Efecto adicional para forzar la actualizaci√≥n de fechas al iniciar la aplicaci√≥n
  useEffect(() => {
    // Ejecutar una actualizaci√≥n forzada despu√©s de que el componente se monte completamente
    const forceInitialUpdate = setTimeout(() => {
      console.log('üîÑ Forzando actualizaci√≥n inicial autom√°tica...');
      
      // Actualizar d√≠as de la semana
      const updatedWeekDays = initializeWeekDays();
      setWeekDaysWithDates(updatedWeekDays);
      
      // Seleccionar el d√≠a actual
      const now = new Date();
      const todayDayOfWeek = now.getDay();
      const todayDay = updatedWeekDays.find(day => parseInt(day.id, 10) === todayDayOfWeek);
      
      if (todayDay) {
        setSelectedDay(todayDay);
        console.log(`D√≠a seleccionado actualizado: ${todayDay.name} (${todayDay.date})`);
        
        // Actualizar la fecha seleccionada
        const [year, month, day] = todayDay.date.split('-').map(num => parseInt(num, 10));
        const dateObj = new Date(year, month - 1, day);
        setSelectedDate(dateObj);
      }
      
      // Recargar los slots bloqueados
      loadBlockedSlots().then(() => {
        console.log('‚úÖ Actualizaci√≥n inicial completada');
        
        // Forzar actualizaci√≥n de la UI
        setForceUpdate(prev => prev + 1);
      });
    }, 2000); // Esperar 2 segundos despu√©s de montar el componente
    
    return () => clearTimeout(forceInitialUpdate);
  }, []); // Este efecto se ejecuta solo una vez al montar el componente

  // Funci√≥n para obtener el ID del manager de forma segura
  const getValidManagerId = () => {
    if (!user) {
      console.log('Usuario no disponible');
      return null;
    }
    
    // Preferir siempre el ID de OAuth si est√° disponible
    if (user.sub) {
      console.log('Usando sub del usuario (OAuth ID):', user.sub);
      return user.sub;
    }
    
    // En SpaceAvailabilityManager se usa _id directamente
    if (user._id) {
      console.log('Usando _id del usuario:', user._id);
      return user._id;
    }
    
    // Si no hay _id pero hay id, usamos ese
    if (user.id) {
      console.log('Usando id del usuario:', user.id);
      return user.id;
    }
    
    console.log('Usuario sin ID v√°lido');
    return null;
  };

  // Funci√≥n para guardar la configuraci√≥n de disponibilidad
  const saveAvailabilityToStorage = async (settings) => {
    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.log('No se pudo guardar disponibilidad: ID de manager inv√°lido');
        return;
      }
      
      // Guardar en AsyncStorage
      const key = `availability_${managerId}`;
      await AsyncStorage.setItem(key, JSON.stringify(settings));
      console.log('Disponibilidad guardada correctamente');
    } catch (error) {
      console.log('Error al guardar la disponibilidad en el almacenamiento local:', error);
    }
  };

  // Funci√≥n para guardar los slots bloqueados
  const saveBlockedSlotsToStorage = async (slots) => {
    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.log('No se pudo guardar slots bloqueados: ID de manager inv√°lido');
        return;
      }
      
      // Asegurarnos de que los slots tengan el formato correcto antes de guardarlos
      const formattedSlots = slots.map(slot => {
        // Asegurarnos de que day y hour sean n√∫meros
        const day = typeof slot.day === 'string' ? parseInt(slot.day, 10) : slot.day;
        const hour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
        
        return {
          ...slot,
          day: day,
          hour: hour,
          // A√±adir un campo compuesto para facilitar la b√∫squeda exacta
          dayHourKey: `${day}-${hour}`
        };
      });
      
      // Guardar en AsyncStorage
      const key = `blockedSlots_${managerId}`;
      await AsyncStorage.setItem(key, JSON.stringify(formattedSlots));
      console.log('Slots bloqueados guardados correctamente:', formattedSlots);
    } catch (error) {
      console.log('Error al guardar slots bloqueados en el almacenamiento local:', error);
    }
  };

  const loadSpaceData = async () => {
    if (!user) {
      console.log('No hay usuario autenticado');
      return null;
    }

    try {
      const managerId = getValidManagerId();
      if (!managerId) {
        console.log('ID de manager inv√°lido, no se cargar√° informaci√≥n de espacio');
        return null;
      }

      // Cargar datos del espacio cultural
      console.log(`Cargando datos del espacio cultural para manager ID: ${managerId}`);
      const response = await axios.get(`${BACKEND_URL}/api/cultural-spaces/manager/${managerId}`);
      
      if (response.data && response.data.success && response.data.space) {
        console.log('Datos del espacio cultural cargados correctamente:', response.data.space);
        setSpaceData(response.data.space);
        return response.data.space;
      } else {
        console.log('No se encontr√≥ informaci√≥n del espacio cultural:', response.data);
        // Crear un objeto de espacio cultural por defecto
        const defaultSpace = {
          nombreEspacio: 'Mi Espacio Cultural',
          id: managerId
        };
        setSpaceData(defaultSpace);
        return defaultSpace;
      }
    } catch (error) {
      console.log('Error al cargar informaci√≥n del espacio cultural:', error.message);
      // En caso de error, establecer un nombre por defecto
      const defaultSpace = {
        nombreEspacio: 'Mi Espacio Cultural',
        id: getValidManagerId()
      };
      setSpaceData(defaultSpace);
      return defaultSpace;
    } 
  };

  const loadEvents = async () => {
    // Inicializar con array vac√≠o para evitar errores
    setEvents([]);
    
    try {
      // Intentar cargar eventos del backend
      const spaceId = user.id; // O usar el ID del espacio cultural si est√° disponible
      const response = await axios.get(`${BACKEND_URL}/api/events/space/${spaceId}`, {
        // Opci√≥n para evitar que se muestre el error en la consola
        validateStatus: (status) => {
          return status < 500; // Resuelve s√≥lo si el c√≥digo de estado es menor que 500
        }
      });
      
      if (response.data && response.data.success) {
        setEvents(response.data.events);
      }
    } catch (error) {
      console.error('Error al cargar eventos:', error);
      // Cargar datos ficticios para desarrollo si falla
      setEvents([]);
    }
  };

  const loadAvailabilitySettings = async (date = null) => {
    try {
      setIsLoading(true);
      
      const managerId = getValidManagerId();
      if (!managerId) {
        console.error('No se pudo cargar disponibilidad: ID de manager inv√°lido');
        setIsLoading(false);
        return;
      }
      
      // Construir la URL base
      let url = `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`;
      
      // Si hay una fecha espec√≠fica, a√±adirla como par√°metro
      if (date) {
        date = date.toISOString().split('T')[0];
        url += `?date=${date}`;
        console.log(`Cargando disponibilidad para fecha espec√≠fica: ${date}`);
      }
      
      console.log(`Solicitando disponibilidad desde URL: ${url}`);
      
      const response = await axios.get(url, { timeout: 10000 });
      
      setIsLoading(false);
      
      if (response.data && response.data.success) {
        const availabilityData = response.data.availability;
        
        // Si estamos cargando una fecha espec√≠fica y no hay datos, pero tenemos canCreateConfig
        if (date && Object.keys(availabilityData).length === 0 && response.data.canCreateConfig) {
          console.log('No hay configuraci√≥n espec√≠fica para esta fecha, pero se puede crear');
          
          // Preguntar al usuario si desea crear una configuraci√≥n espec√≠fica
          if (!isConfiguringSpecificDate) {
            Alert.alert(
              'Configuraci√≥n no encontrada',
              `No hay configuraci√≥n espec√≠fica para ${date}. ¬øDeseas crear una?`,
              [
                {
                  text: 'No',
                  style: 'cancel',
                  onPress: () => {
                    // Volver a cargar la configuraci√≥n general
                    setUseSpecificDate(false);
                    setConfigSpecificDate(null);
                    loadAvailabilitySettings();
                  }
                },
                {
                  text: 'S√≠, configurar',
                  onPress: () => {
                    // Configurar para fecha espec√≠fica
                    setUseSpecificDate(true);
                    setConfigSpecificDate(new Date(date));
                    
                    // Abrir el modal para configurar
                    setModalMode('availability');
                    setModalVisible(true);
                  }
                }
              ]
            );
          }
          return;
        }
        
        // Actualizar el estado con los datos recibidos
        setAvailabilitySettings(availabilityData);
        console.log('Configuraci√≥n de disponibilidad cargada:', availabilityData);
        
        // Si hay fecha espec√≠fica en la respuesta, actualizar el estado
        if (response.data.isSpecificDate) {
          setUseSpecificDate(true);
          if (response.data.date) {
            setConfigSpecificDate(new Date(response.data.date));
          }
        }
      } else {
        console.error('Error al cargar disponibilidad:', response.data?.message);
      }
    } catch (error) {
      console.error('Error al cargar configuraci√≥n de disponibilidad:', error);
      setIsLoading(false);
    }
  };

  const loadBlockedSlots = async () => {
    try {
      console.log('üîç Iniciando carga de slots bloqueados...');
      
      const managerId = getValidManagerId();
      if (!managerId) {
        console.error('ID de manager inv√°lido al cargar slots bloqueados');
        return [];
      }
      
      console.log('üîç Buscando slots bloqueados para manager:', managerId);
      
      // Limpiar el estado actual
      setBlockedSlots([]);
      setBlockedSlotsByDate({});
      
      // Intentar cargar desde el servidor
      try {
        const response = await axios.get(`${BACKEND_URL}/api/spaces/blocked-slots/${managerId}`);
        console.log('Respuesta del servidor:', response.status);
        
        // Determinar la estructura de los datos recibidos
        let serverSlots = [];
        
        if (response.data) {
          if (Array.isArray(response.data)) {
            // Si la respuesta es directamente un array
            serverSlots = response.data;
            console.log('Respuesta es un array directamente');
          } else if (response.data.blockedSlots && Array.isArray(response.data.blockedSlots)) {
            // Si la respuesta tiene un campo blockedSlots que es un array
            serverSlots = response.data.blockedSlots;
            console.log('Respuesta tiene campo blockedSlots');
          } else if (typeof response.data === 'object') {
            // Si la respuesta es un objeto, intentar convertirlo a array
            console.log('Respuesta es un objeto, intentando extraer slots');
            // Verificar si hay alguna propiedad que podr√≠a contener los slots
            for (const key in response.data) {
              if (Array.isArray(response.data[key])) {
                serverSlots = response.data[key];
                console.log(`Encontrados slots en propiedad: ${key}`);
                break;
              }
            }
            
            // Si no se encontr√≥ ning√∫n array, usar el objeto como un solo slot
            if (serverSlots.length === 0 && response.data.hour !== undefined) {
              serverSlots = [response.data];
              console.log('Usando el objeto de respuesta como un solo slot');
            }
          }
        }
        
        console.log(`üìã Slots bloqueados recibidos del servidor: ${serverSlots.length}`);
        
        // IMPORTANTE: Procesar los slots usando fechas locales correctas
        const processedSlots = serverSlots.map(slot => {
          // Asegurarnos de que hour sea n√∫mero
          const hour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
          
          // Obtener la fecha del slot
          let slotDate = null;
          
          // Priorizar date sobre dateStr para evitar duplicados
          if (slot.date) {
            slotDate = typeof slot.date === 'string' ? slot.date : slot.date.toISOString().split('T')[0];
          } else if (slot.dateStr) {
            slotDate = slot.dateStr;
          }
          
          // Determinar el d√≠a de la semana a partir de la fecha
          let day = slot.day;
          
          // Si tenemos una fecha, asegur√©monos de que el d√≠a sea correcto
          if (slotDate) {
            try {
              // Crear un objeto Date a partir de la cadena de fecha (USANDO FECHA LOCAL)
              const dateParts = slotDate.split('-');
              if (dateParts.length === 3) {
                const [year, month, dayOfMonth] = dateParts.map(num => parseInt(num, 10));
                
                // Crear fecha local sin ajuste de zona horaria
                const dateObj = new Date(year, month - 1, dayOfMonth);
                
                // Obtener el d√≠a de la semana (0 = domingo, 1 = lunes, ..., 6 = s√°bado)
                day = dateObj.getDay();
                
                console.log(`‚úÖ Fecha ${slotDate} corresponde a d√≠a ${day} (${getDayName(day)})`);
              }
            } catch (error) {
              console.error(`Error al determinar d√≠a para fecha ${slotDate}:`, error);
            }
          }
          
          // Crear el slot con todos los campos necesarios
          return {
            id: slot.id || `server-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            hour: hour,
            date: slotDate,
            dateStr: slotDate,
            day: day,
            dayName: slot.dayName || (day !== undefined ? getDayName(day) : null),
            fromServer: true
          };
        });
        
        console.log(`üìã Slots procesados: ${processedSlots.length}`);
        
        // Eliminar duplicados basados en fecha y hora
        const uniqueSlots = processedSlots.filter((slot, index, self) => {
          // Crear una clave √∫nica basada en fecha y hora
          const key = `${slot.date || ''}-${slot.hour}`;
          // Mantener solo la primera ocurrencia con esta clave
          return index === self.findIndex(s => `${s.date || ''}-${s.hour}` === key);
        });
        
        console.log(`üìã Slots bloqueados √∫nicos: ${uniqueSlots.length}`);
        
        // Actualizar el estado
        setBlockedSlots(uniqueSlots);
        
        // Crear el mapa de slots bloqueados por fecha
        const newBlockedSlotsByDate = {};
        
        uniqueSlots.forEach(slot => {
          const slotDate = slot.date || slot.dateStr;
          
          if (slotDate) {
            if (!newBlockedSlotsByDate[slotDate]) {
              newBlockedSlotsByDate[slotDate] = [];
            }
            
            // Verificar que no exista ya un slot para esta fecha y hora
            const exists = newBlockedSlotsByDate[slotDate].some(s => s.hour === slot.hour);
            
            if (!exists) {
              newBlockedSlotsByDate[slotDate].push(slot);
              console.log(`‚úÖ Agregado slot bloqueado para fecha ${slotDate}, hora=${slot.hour}, d√≠a=${slot.day}`);
            }
          }
        });
        
        console.log('Mapa de slots bloqueados por fecha creado:', Object.keys(newBlockedSlotsByDate));
        setBlockedSlotsByDate(newBlockedSlotsByDate);
        
        // Guardar en AsyncStorage como respaldo
        AsyncStorage.setItem(`blockedSlots_${managerId}`, JSON.stringify(uniqueSlots));
        
        // Ejecutar depuraci√≥n para verificar
        setTimeout(() => {
          debugWeekDays();
          debugBlockedSlots();
        }, 500);
        
        return uniqueSlots;
      } catch (serverError) {
        console.error('Error al cargar slots bloqueados desde el servidor:', serverError);
        // Continuar con la carga desde AsyncStorage
      }
      
      // Si no se pudo cargar del servidor, intentar desde AsyncStorage
      try {
        const storedSlots = await AsyncStorage.getItem(`blockedSlots_${managerId}`);
        if (storedSlots) {
          const parsedSlots = JSON.parse(storedSlots);
          console.log(`üìã Slots bloqueados cargados desde AsyncStorage: ${parsedSlots.length}`);
          
          // Actualizar el estado
          setBlockedSlots(parsedSlots);
          
          // Crear el mapa de slots bloqueados por fecha
          const newBlockedSlotsByDate = {};
          
          parsedSlots.forEach(slot => {
            const slotDate = slot.date || slot.dateStr;
            
            if (slotDate) {
              if (!newBlockedSlotsByDate[slotDate]) {
                newBlockedSlotsByDate[slotDate] = [];
              }
              
              // Verificar que no exista ya un slot para esta fecha y hora
              const exists = newBlockedSlotsByDate[slotDate].some(s => s.hour === slot.hour);
              
              if (!exists) {
                newBlockedSlotsByDate[slotDate].push(slot);
              }
            }
          });
          
          console.log('Mapa de slots bloqueados por fecha creado desde AsyncStorage:', Object.keys(newBlockedSlotsByDate));
          setBlockedSlotsByDate(newBlockedSlotsByDate);
          
          // Ejecutar depuraci√≥n para verificar
          setTimeout(() => {
            debugWeekDays();
            debugBlockedSlots();
          }, 500);
          
          return parsedSlots;
        } else {
          console.log('No hay slots bloqueados guardados localmente');
          setBlockedSlots([]);
          setBlockedSlotsByDate({});
          return [];
        }
      } catch (storageError) {
        console.error('Error al cargar slots bloqueados desde AsyncStorage:', storageError);
        setBlockedSlots([]);
        setBlockedSlotsByDate({});
        return [];
      }
    } catch (error) {
      console.error('Error general al cargar slots bloqueados:', error);
      setBlockedSlots([]);
      setBlockedSlotsByDate({});
      return [];
    }
  };

  const debugBlockedSlots = () => {
    console.log('üîç DEPURACI√ìN DE SLOTS BLOQUEADOS:');
    console.log(`üìã Total de slots bloqueados: ${blockedSlots.length}`);
    console.log('üìã Mapa de slots bloqueados por fecha:', Object.keys(blockedSlotsByDate));
    
    // Mostrar todos los slots bloqueados
    console.log('üìã Lista completa de slots bloqueados:');
    blockedSlots.forEach((slot, index) => {
      console.log(`üìå Slot ${index + 1}:`);
      console.log(`   ID: ${slot.id}`);
      console.log(`   Fecha: ${slot.date || 'No especificada'}`);
      console.log(`   DateStr: ${slot.dateStr || 'No especificada'}`);
      console.log(`   D√≠a: ${slot.day} (${getDayName(slot.day) || 'No especificado'})`);
      console.log(`   Hora: ${slot.hour}`);
    });
    
    // Mostrar slots por fecha
    console.log('üìã Slots bloqueados por fecha:');
    Object.keys(blockedSlotsByDate).forEach(dateKey => {
      console.log(`üìÖ Fecha: ${dateKey}, Slots: ${blockedSlotsByDate[dateKey].length}`);
      blockedSlotsByDate[dateKey].forEach((slot, index) => {
        console.log(`  üìå Slot ${index + 1}: hora=${slot.hour}, d√≠a=${slot.day}, id=${slot.id}`);
      });
    });
    
    // Verificar qu√© slots se mostrar√≠an para la fecha seleccionada
    const currentDate = selectedDate ? selectedDate.toISOString().split('T')[0] : null;
    if (currentDate) {
      debugBlockedSlotsForDate(currentDate);
    }
    
    // Verificar slots para el d√≠a seleccionado
    if (selectedDay) {
      const selectedDayWithDate = weekDaysWithDates.find(day => parseInt(day.id, 10) === parseInt(selectedDay.id, 10));
      const dayDate = selectedDayWithDate?.date || null;
      if (dayDate && dayDate !== currentDate) {
        debugBlockedSlotsForDate(dayDate);
      }
    }
    
    // Verificar el estado de weekDaysWithDates
    console.log('üìÖ Estado actual de weekDaysWithDates:');
    weekDaysWithDates.forEach((day, index) => {
      console.log(`  üìÜ D√≠a ${index + 1}: id=${day.id}, nombre=${day.name}, fecha=${day.date}`);
    });
  };
  
  // Funci√≥n para depurar slots bloqueados para una fecha espec√≠fica
  const debugBlockedSlotsForDate = (dateStr) => {
    console.log(`Verificando slots bloqueados para fecha: ${dateStr}`);
    
    if (blockedSlotsByDate[dateStr]) {
      console.log(`Encontrados ${blockedSlotsByDate[dateStr].length} slots bloqueados para esta fecha`);
      blockedSlotsByDate[dateStr].forEach((slot, index) => {
        console.log(`  Slot ${index + 1}: hora=${slot.hour}, d√≠a=${slot.day}, id=${slot.id}`);
      });
    } else {
      console.log('No hay slots bloqueados para esta fecha');
    }
  };

  const debugSelectedDate = () => {
    if (!selectedDay) {
      console.log('No hay d√≠a seleccionado');
      return;
    }
    
    const selectedDayWithDate = weekDaysWithDates.find(day => parseInt(day.id, 10) === parseInt(selectedDay.id, 10));
    const currentDayDate = selectedDayWithDate?.date || null;
    
    console.log(`D√≠a seleccionado: ${selectedDay.name} (${selectedDay.id})`);
    console.log(`Fecha del d√≠a seleccionado: ${currentDayDate}`);
    
    // Verificar slots bloqueados para esta fecha
    if (currentDayDate && blockedSlotsByDate[currentDayDate]) {
      console.log(`Slots bloqueados para ${currentDayDate}: ${blockedSlotsByDate[currentDayDate].length}`);
      blockedSlotsByDate[currentDayDate].forEach((slot, index) => {
        console.log(`  Slot ${index + 1}: hora=${slot.hour}, d√≠a=${slot.day}, id=${slot.id}`);
      });
    } else {
      console.log(`No hay slots bloqueados para la fecha ${currentDayDate}`);
    }
    
    // Verificar todas las fechas en blockedSlotsByDate
    console.log('Todas las fechas con slots bloqueados:');
    Object.keys(blockedSlotsByDate).forEach(dateKey => {
      console.log(`  Fecha: ${dateKey}, Slots: ${blockedSlotsByDate[dateKey].length}`);
    });
  };

  const handleDayPress = (day) => {
    console.log(`D√≠a seleccionado: ${day.name} (${day.date})`);
    
    // Actualizar el d√≠a seleccionado
    setSelectedDay(day);
    
    // Actualizar la fecha seleccionada si existe
    if (day.date) {
      try {
        // Crear un objeto Date a partir de la cadena de fecha
        const [year, month, dayNum] = day.date.split('-').map(num => parseInt(num, 10));
        const dateObj = new Date(year, month - 1, dayNum);
        
        // Verificar que la fecha sea v√°lida
        if (!isNaN(dateObj.getTime())) {
          console.log(`Fecha seleccionada: ${dateObj.toISOString()}`);
          setSelectedDate(dateObj);
          
          // Verificar si hay slots bloqueados para esta fecha
          const blockedForDate = blockedSlotsByDate[day.date] || [];
          console.log(`Slots bloqueados para fecha ${day.date}: ${blockedForDate.length}`);
          
          if (blockedForDate.length > 0) {
            console.log('Slots bloqueados para esta fecha:');
            blockedForDate.forEach(slot => {
              console.log(`- Hora: ${slot.hour}, D√≠a: ${slot.day} (${getDayName(slot.day)})`);
            });
          }
        }
      } catch (error) {
        console.error(`Error al procesar fecha ${day.date}:`, error);
      }
    }
    
    // Forzar actualizaci√≥n de la UI
    setForceUpdate(prev => prev + 1);
  };

  const handleTimeSlotSelect = (slot) => {
    setSelectedTimeSlot(slot);
    
    // Verificar si la franja est√° bloqueada
    const slotIsBlocked = isSlotBlocked(slot.id, selectedDay);
    console.log(`Slot seleccionado: d√≠a=${selectedDay?.id}, hora=${slot.id}, bloqueado=${slotIsBlocked}`);
    
    // Verificar si hay un evento en esta franja
    const event = events.find(event => 
      new Date(event.fecha).getDay() === selectedDay?.id && 
      parseInt(event.horaInicio.split(':')[0]) === slot.id
    );
    
    if (slotIsBlocked) {
      // Si est√° bloqueada, mostrar modal para desbloquear
      console.log('Mostrando modal para desbloquear');
      setModalMode('unblock');
      setModalVisible(true);
      
      // CORRECCI√ìN: Eliminada la alerta duplicada para evitar confusi√≥n
      // Ahora solo se muestra el modal con la opci√≥n de desbloquear
    } else if (event) {
      // Si hay un evento, mostrar detalles del evento
      console.log('Mostrando modal de informaci√≥n de evento');
      setModalMode('info');
      setModalVisible(true);
    } else {
      // Si est√° disponible pero no tiene evento, mostrar opciones para bloquear
      console.log('Mostrando modal para bloquear');
      setModalMode('block');
      setModalVisible(true);
    }
  };

  // Funci√≥n para verificar si un slot est√° bloqueado
  const isSlotBlocked = (hour, dayObj) => {
    // Verificar que tengamos los datos necesarios
    if (!dayObj || !dayObj.date || !hour) {
      console.log('‚ùå Datos insuficientes para verificar slot bloqueado');
      return false;
    }

    // Obtener la fecha del d√≠a
    const dayDate = dayObj.date; // Formato: YYYY-MM-DD

    // Verificar si hay slots bloqueados para esta fecha espec√≠fica
    if (blockedSlotsByDate && blockedSlotsByDate[dayDate]) {
      // Buscar si hay un slot bloqueado para esta hora en esta fecha espec√≠fica
      const isBlocked = blockedSlotsByDate[dayDate].some(slot => {
        const slotHour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
        const hourToCheck = typeof hour === 'string' ? parseInt(hour, 10) : hour;

        // COMPARACI√ìN DIRECTA: Solo verificar que la hora coincida, ya que estamos filtrando por fecha exacta
        const hourMatches = slotHour === hourToCheck;

        if (hourMatches) {
          console.log(`‚úÖ Slot bloqueado encontrado: fecha=${dayDate}, hora=${hour}`);
        }

        return hourMatches;
      });

      return isBlocked;
    }

    // No hay slots bloqueados para esta fecha
    return false;
  };

  const renderTimeSlot = (slot, day) => {
    const hourId = parseInt(slot.id, 10);
    const dayId = parseInt(day.id, 10);
    
    // IMPORTANTE: Obtener la fecha espec√≠fica del d√≠a actual
    const currentDayDate = day.date;
    
    // SOLUCI√ìN DIRECTA: Verificar SOLO la fecha actual (no fechas adyacentes)
    // Esto evita que los slots bloqueados aparezcan en m√∫ltiples d√≠as
    let isBlockedSlot = false;
    
    // Verificar si el slot est√° bloqueado para esta fecha espec√≠fica
    if (currentDayDate && blockedSlotsByDate && blockedSlotsByDate[currentDayDate]) {
      const blockedSlotsForDate = blockedSlotsByDate[currentDayDate];
      
      isBlockedSlot = blockedSlotsForDate.some(blockedSlot => {
        const blockedHour = typeof blockedSlot.hour === 'string' ? parseInt(blockedSlot.hour, 10) : blockedSlot.hour;
        return blockedHour === hourId;
      });
      
      if (isBlockedSlot) {
        console.log(`‚úÖ Slot bloqueado encontrado en fecha ${currentDayDate}, hora=${hourId}`);
      }
    }
    
    // Verificar disponibilidad
    const isAvailable = availabilitySettings[dayId]?.includes(hourId);
    
    // Verificar si hay un evento en este slot
    const event = events.find(
      e => e.day === dayId && e.hour === hourId
    );
    
    // Aplicar estilo directo para slots bloqueados con un color rojo m√°s oscuro
    const slotStyle = isBlockedSlot ? [
        styles.timeSlot,
        styles.blockedSlot,
        {
          backgroundColor: '#990000', // Rojo m√°s oscuro
          borderColor: '#990000'
        }
      ] : [
        styles.timeSlot,
        isAvailable ? styles.availableSlot : styles.unavailableSlot,
        event && styles.eventSlot
      ];
    
    // Determinar el estilo del texto
    const textStyle = isBlockedSlot ? [styles.timeText, styles.blockedText] : [styles.timeText, isAvailable ? styles.availableText : styles.unavailableText];
    
    return (
      <TouchableOpacity
        key={`${dayId}-${hourId}`}
        style={slotStyle}
        onPress={() => {
          // Si el slot est√° bloqueado, mostrar opci√≥n para desbloquear
          if (isBlockedSlot) {
            // Buscar el slot bloqueado espec√≠fico
            let blockedSlot = null;
            
            // Buscar en la fecha actual
            if (currentDayDate && blockedSlotsByDate && blockedSlotsByDate[currentDayDate]) {
              blockedSlot = blockedSlotsByDate[currentDayDate].find(bs => {
                const bsHour = typeof bs.hour === 'string' ? parseInt(bs.hour, 10) : bs.hour;
                return bsHour === hourId;
              });
            }
            
            showUnblockModal(day, slot, blockedSlot);
          } else {
            handleTimeSlotSelect(slot);
          }
        }}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center' }}>
          <Text style={textStyle}>{`${slot.hour}:00 ${slot.period}`}</Text>
          {isBlockedSlot && (
            <Ionicons name="lock-closed" size={16} color="#FFFFFF" style={{ marginLeft: 5 }} />
          )}
        </View>
      </TouchableOpacity>
    );
  };

  const renderTimeSlots = () => {
    if (!selectedDay) {
      return null;
    }
    
    return timeSlots.map(slot => renderTimeSlot(slot, selectedDay));
  };

  // Funci√≥n auxiliar para obtener el nombre del d√≠a a partir de su ID
  const getDayName = (dayId) => {
    const days = [
      'Domingo',  // 0
      'Lunes',    // 1
      'Martes',   // 2
      'Mi√©rcoles',// 3
      'Jueves',   // 4
      'Viernes',  // 5
      'S√°bado'    // 6
    ];
    
    // Asegurar que dayId sea un n√∫mero
    const dayIdNum = typeof dayId === 'string' ? parseInt(dayId, 10) : dayId;
    
    // Asegurar que el √≠ndice est√© dentro del rango v√°lido (0-6)
    const index = ((dayIdNum % 7) + 7) % 7;
    
    return days[index];
  };

  const updateAvailability = (day, slot, isAvailable) => {
    if (!day || !slot) {
      console.error('D√≠a o slot no v√°lidos para actualizar disponibilidad');
      return;
    }
    
    const dayId = parseInt(day.id, 10);
    const slotId = parseInt(slot.id, 10);
    
    console.log(`Actualizando disponibilidad: d√≠a=${dayId}, hora=${slotId}, disponible=${isAvailable}`);
    
    // Crear una copia del estado actual para modificarlo
    const updatedSettings = { ...availabilitySettings };
    
    // Inicializar el array para este d√≠a si no existe
    if (!updatedSettings[dayId]) {
      updatedSettings[dayId] = [];
    }
    
    if (isAvailable) {
      // Si debe estar disponible, a√±adir el slot si no est√° ya
      if (!updatedSettings[dayId].includes(slotId)) {
        updatedSettings[dayId].push(slotId);
      }
    } else {
      // Si no debe estar disponible, eliminar el slot si est√°
      updatedSettings[dayId] = updatedSettings[dayId].filter(id => id !== slotId);
    }
    
    // Actualizar el estado
    setAvailabilitySettings(updatedSettings);
    
    // Forzar actualizaci√≥n de la UI
    setForceUpdate(prev => prev + 1);
  };

  const handleResetBlockedSlots = async () => {
    // Mostrar confirmaci√≥n antes de eliminar todos los slots bloqueados
    Alert.alert(
      'Confirmar Acci√≥n',
      '¬øEst√°s seguro de que deseas eliminar todas las franjas bloqueadas y restablecer la disponibilidad?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Confirmar',
          style: 'destructive',
          onPress: async () => {
            try {
              // Obtener el ID del manager
              const managerId = getValidManagerId();
              if (!managerId) {
                Alert.alert('Error', 'ID de manager inv√°lido');
                return;
              }
              
              // Mostrar mensaje de carga
              Alert.alert('Procesando', 'Restableciendo disponibilidad...');
              
              // 1. Eliminar slots bloqueados locales
              await AsyncStorage.removeItem(`blockedSlots_${managerId}`);
              
              // 2. Intentar eliminar slots del servidor
              try {
                const response = await axios.post(`${BACKEND_URL}/api/spaces/reset-configuration/${managerId}`);
                console.log('Respuesta del servidor al restablecer slots:', response.data);
              } catch (serverError) {
                console.error('Error al restablecer slots en el servidor:', serverError);
                // Continuar con el proceso local incluso si hay error en el servidor
              }
              
              // 3. Limpiar el estado local
              setBlockedSlots([]);
              
              // 4. Mostrar mensaje de √©xito
              Alert.alert(
                '√âxito',
                'Se ha restablecido la disponibilidad correctamente.',
                [{ text: 'OK' }]
              );
              
              // 5. Recargar los datos
              await loadBlockedSlots();
              
            } catch (error) {
              console.error('Error al restablecer disponibilidad:', error);
              Alert.alert('Error', 'No se pudo restablecer la disponibilidad. Int√©ntalo de nuevo.');
            }
          }
        }
      ]
    );
  };

  // Funci√≥n para verificar la conexi√≥n con el servidor
  const checkServerConnection = async () => {
    try {
      const response = await axios.get(`${BACKEND_URL}/api/health`, { timeout: 5000 });
      return response.status === 200;
    } catch (error) {
      console.log('Error al verificar conexi√≥n con el servidor:', error.message);
      return false;
    }
  };

  const loadAvailabilityWithRetry = async (retries = 3) => {
    const isConfiguringSpecificDate = modalVisible && modalMode === 'availability' && configSpecificDate;
    
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        if (!isConfiguringSpecificDate) {
          setIsLoading(true);
        }
        
        // Asegurarnos que managerId sea un n√∫mero v√°lido
        const managerId = getValidManagerId();
        if (!managerId) {
          console.log('No se pudo cargar disponibilidad: ID de manager inv√°lido');
          initializeDefaultAvailability();
          setIsLoading(false);
          return;
        }
        
        // Intentar cargar desde AsyncStorage primero para mostrar algo inmediatamente
        const key = `availability_${managerId}`;
        const storedSettings = await AsyncStorage.getItem(key);
        if (storedSettings) {
          setAvailabilitySettings(JSON.parse(storedSettings));
        } else {
          initializeDefaultAvailability();
        }
        
        // Construir la URL base
        let url = `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`;
        
        // Si hay una fecha espec√≠fica, a√±adirla como par√°metro de consulta
        let dateParam = '';
        if (configSpecificDate) {
          dateParam = configSpecificDate.toISOString().split('T')[0];
          url += `?date=${dateParam}`;
          console.log(`Cargando disponibilidad para fecha espec√≠fica: ${dateParam}`);
        }
        
        console.log(`Intento ${attempt}/${retries}: Solicitando disponibilidad desde URL:`, url);
        
        // Mostrar informaci√≥n detallada sobre los datos que se enviar√°n
        const diasConfig = Object.keys(availabilitySettings).length;
        console.log(`Configurando ${diasConfig} d√≠as${configSpecificDate ? ` para fecha espec√≠fica: ${configSpecificDate.toLocaleDateString()}` : ' (configuraci√≥n general)'}`);
        
        // Preparar datos para enviar al backend
        const requestData = {
          availability: availabilitySettings
        };
        
        // Si estamos configurando para una fecha espec√≠fica, incluirla
        if (configSpecificDate) {
          requestData.date = configSpecificDate.toISOString().split('T')[0];
          console.log(`Configurando disponibilidad para fecha espec√≠fica: ${requestData.date}`);
        } else {
          console.log('Configurando disponibilidad general (sin fecha espec√≠fica)');
        }
        
        // Enviar la configuraci√≥n limpia al backend con timeout
        console.log('Enviando datos al servidor:', JSON.stringify(requestData));
        const response = await axios.get(url, { timeout: 10000 }); // Timeout de 10 segundos
        
        if (!isConfiguringSpecificDate) {
          setIsLoading(false);
        }
        
        console.log('Respuesta recibida:', response.status);
        
        if (response.data && response.data.success) {
          console.log('Datos de disponibilidad recibidos:', {
            d√≠as: Object.keys(response.data.availability).length,
            fecha: response.data.date,
            esEspec√≠fica: response.data.isSpecificDate,
            puedeCrearConfig: response.data.canCreateConfig
          });
          
          // Verificar si hay datos de disponibilidad
          if (Object.keys(response.data.availability).length > 0) {
            setAvailabilitySettings(response.data.availability);
            saveAvailabilityToStorage(response.data.availability);
            
            // Mostrar mensaje seg√∫n el tipo de configuraci√≥n
            if (configSpecificDate && !isConfiguringSpecificDate) {
              if (response.data.isSpecificDate) {
                console.log('Usando configuraci√≥n espec√≠fica para la fecha seleccionada');
                // No mostrar alerta para no interrumpir la experiencia del usuario
              } else {
                console.log('Usando configuraci√≥n recurrente (no hay configuraci√≥n espec√≠fica para esta fecha)');
                if (showNotifications && response.data.canCreateConfig) {
                  Alert.alert(
                    'Configuraci√≥n para fecha espec√≠fica',
                    `No hay configuraci√≥n espec√≠fica para ${configSpecificDate.toLocaleDateString()}. ¬øDeseas crear una?`,
                    [
                      { text: 'No', style: 'cancel' },
                      { 
                        text: 'S√≠, configurar', 
                        onPress: () => {
                          // Inicializar con la configuraci√≥n general actual como base
                          const currentConfig = {...availabilitySettings};
                          setAvailabilitySettings(currentConfig);
                          
                          // Detener cualquier proceso de carga en curso
                          setIsLoading(false);
                          
                          // Guardar la fecha espec√≠fica en una variable local
                          const dateToUse = new Date(configSpecificDate);
                          
                          // Usar setTimeout para asegurar que el modal se abra despu√©s de que
                          // se haya cerrado el di√°logo de alerta
                          setTimeout(() => {
                            console.log('Abriendo modal de configuraci√≥n para fecha espec√≠fica:', dateToUse.toLocaleDateString());
                            setConfigSpecificDate(dateToUse);
                            setModalMode('availability');
                            setModalVisible(true);
                            setUseSpecificDate(true);
                          }, 500);
                        },
                        style: 'default'
                      }
                    ]
                  );
                } else if (showNotifications) {
                  Alert.alert('Informaci√≥n', `No hay configuraci√≥n espec√≠fica para ${configSpecificDate.toLocaleDateString()}, mostrando configuraci√≥n general`);
                }
              }
            }
          } else {
            console.log('No se encontraron datos de disponibilidad');
            if (configSpecificDate && showNotifications && !isConfiguringSpecificDate) {
              if (response.data.canCreateConfig) {
                Alert.alert(
                  'Sin configuraci√≥n',
                  `No hay configuraci√≥n para ${configSpecificDate.toLocaleDateString()}. ¬øDeseas crear una configuraci√≥n espec√≠fica para esta fecha?`,
                  [
                    {
                      text: 'No',
                      style: 'cancel',
                      onPress: () => {
                        // Volver a cargar la configuraci√≥n general
                        setUseSpecificDate(false);
                        setConfigSpecificDate(null);
                        loadAvailabilitySettings();
                      }
                    },
                    {
                      text: 'S√≠, configurar',
                      onPress: () => {
                        // Configurar para fecha espec√≠fica
                        setUseSpecificDate(true);
                        setConfigSpecificDate(date);
                        
                        // Abrir el modal para configurar
                        setModalMode('availability');
                        setModalVisible(true);
                      }
                    }
                  ]
                );
              } else {
                Alert.alert('Informaci√≥n', `No hay configuraci√≥n para ${configSpecificDate.toLocaleDateString()}`);
              }
            }
          }
          
          // Si llegamos aqu√≠, la carga fue exitosa
          return;
        } else {
          console.log('Error en la respuesta:', response.data);
          if (attempt === retries && showNotifications) {
            Alert.alert('Error', 'No se pudo cargar la disponibilidad desde el servidor');
          }
        }
      } catch (error) {
        if (!isConfiguringSpecificDate) {
          setIsLoading(false);
        }
        
        console.log(`Intento ${attempt}/${retries} - Error al cargar disponibilidad:`, error.message);
        
        if (error.code === 'ECONNABORTED') {
          console.log('Timeout al conectar con el servidor');
        }
        
        // Si es el √∫ltimo intento, mostrar mensaje de error
        if (attempt === retries) {
          console.log('Detalles del error:', error.response ? error.response.data : 'No hay detalles adicionales');
          
          // Verificar si el servidor est√° disponible
          const isServerAvailable = await checkServerConnection();
          
          if (!isServerAvailable && showNotifications) {
            Alert.alert(
              'Error de conexi√≥n', 
              'No se pudo conectar con el servidor. Verifica tu conexi√≥n a internet y que el servidor est√© en funcionamiento.',
              [
                { text: 'OK' },
                { 
                  text: 'Reintentar', 
                  onPress: () => loadAvailabilityWithRetry(3) 
                }
              ]
            );
          } else if (showNotifications) {
            Alert.alert('Error', 'No se pudo cargar la disponibilidad. Usando configuraci√≥n guardada localmente.');
          }
        } else {
          // Esperar antes del siguiente intento (tiempo exponencial)
          const waitTime = Math.pow(2, attempt) * 1000;
          console.log(`Esperando ${waitTime}ms antes del siguiente intento...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
      }
    }
  };

  const handleUnblockSlot = async (day, hour, blockedSlot = null) => {
    try {
      setIsLoading(true);
      
      const managerId = getValidManagerId();
      if (!managerId) {
        Alert.alert('Error', 'ID de manager inv√°lido');
        setIsLoading(false);
        return;
      }
      
      // Validar que tengamos valores v√°lidos
      if ((day === undefined || hour === undefined) && !blockedSlot) {
        console.error('Valores faltantes para desbloquear slot:', { day, hour, blockedSlot });
        Alert.alert('Error', 'Informaci√≥n incompleta para desbloquear el horario');
        setIsLoading(false);
        return;
      }
      
      console.log(`Intentando desbloquear slot:`, { day, hour, blockedSlotId: blockedSlot?.id });
      
      let response;
      
      // Si tenemos el ID del slot bloqueado, usar ese endpoint
      if (blockedSlot && blockedSlot.id) {
        console.log(`Desbloqueando por ID: ${blockedSlot.id}`);
        response = await axios.post(`${BACKEND_URL}/api/spaces/unblock-slot-by-id/${blockedSlot.id}`);
      } else {
        // Si no tenemos el ID, usar el endpoint que requiere d√≠a y hora
        // Asegurarnos de que day y hour sean n√∫meros
        const dayNum = typeof day === 'string' ? parseInt(day, 10) : day;
        const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
        
        if (isNaN(dayNum) || isNaN(hourNum)) {
          console.error('Valores inv√°lidos para desbloquear slot:', { day, hour, dayNum, hourNum });
          Alert.alert('Error', 'Valores inv√°lidos para desbloquear el horario');
          setIsLoading(false);
          return;
        }
        
        console.log(`Desbloqueando por d√≠a/hora: ${dayNum}/${hourNum}`);
        
        // Crear un objeto limpio sin referencias circulares
        const requestData = {
          day: dayNum,
          hour: hourNum
        };
        
        // Si hay una fecha espec√≠fica seleccionada, incluirla
        if (selectedDate) {
          requestData.date = selectedDate.toISOString().split('T')[0];
        } else if (configSpecificDate) {
          requestData.date = configSpecificDate.toISOString().split('T')[0];
        }
        
        console.log('Datos de desbloqueo:', JSON.stringify(requestData));
        
        // Asegurarnos de que la URL sea correcta
        const url = `${BACKEND_URL}/api/spaces/unblock-slot/${managerId}`;
        console.log('URL de desbloqueo:', url);
        
        response = await axios.post(url, requestData);
      }
      
      setIsLoading(false);
      
      if (response.data && response.data.success) {
        // Actualizar inmediatamente el estado local de slots bloqueados
        // Esto es crucial para que la interfaz se actualice sin tener que recargar
        if (blockedSlot && blockedSlot.id) {
          // Si tenemos el ID del slot, eliminarlo del array de slots bloqueados
          setBlockedSlots(prevSlots => prevSlots.filter(slot => slot.id !== blockedSlot.id));
        } else {
          // Si no tenemos el ID, eliminar por d√≠a y hora
          const dayNum = typeof day === 'string' ? parseInt(day, 10) : day;
          const hourNum = typeof hour === 'string' ? parseInt(hour, 10) : hour;
          
          setBlockedSlots(prevSlots => {
            return prevSlots.filter(slot => {
              // Si hay fecha espec√≠fica, filtrar por fecha tambi√©n
              if (selectedDate || configSpecificDate) {
                const dateToCheck = selectedDate ? selectedDate : configSpecificDate;
                const dateStr = dateToCheck.toISOString().split('T')[0];
                return !(slot.day === dayNum && slot.hour === hourNum && slot.date === dateStr);
              }
              // Si no hay fecha espec√≠fica, filtrar solo por d√≠a y hora
              return !(slot.day === dayNum && slot.hour === hourNum);
            });
          });
        }
        
        Alert.alert('√âxito', 'Horario desbloqueado correctamente');
        
        // Recargar los slots bloqueados desde el servidor para asegurar sincronizaci√≥n
        loadBlockedSlots();
        
        // Cerrar el modal
        setModalVisible(false);
      } else {
        Alert.alert('Error', 'No se pudo desbloquear el horario: ' + (response.data?.message || 'Error desconocido'));
      }
    } catch (error) {
      console.error('Error al desbloquear slot:', error);
      console.error('Detalles del error:', error.response ? error.response.data : 'No hay detalles adicionales');
      console.error('C√≥digo de estado:', error.response ? error.response.status : 'Desconocido');
      
      setIsLoading(false);
      
      // Mensaje m√°s espec√≠fico seg√∫n el c√≥digo de error
      let errorMessage = 'Error al desbloquear el horario';
      
      if (error.response) {
        if (error.response.status === 400) {
          errorMessage = 'Datos inv√°lidos para desbloquear el horario. Verifica que los valores sean correctos.';
        } else if (error.response.status === 404) {
          errorMessage = 'No se encontr√≥ el slot para desbloquear.';
        } else if (error.response.status === 500) {
          errorMessage = 'Error interno del servidor al desbloquear el horario.';
        }
        
        // Incluir mensaje del servidor si est√° disponible
        if (error.response.data && error.response.data.message) {
          errorMessage += ` Mensaje del servidor: ${error.response.data.message}`;
        }
      }
      
      Alert.alert('Error', errorMessage);
    }
  };

  const showUnblockModal = (day, slot, blockedSlot = null) => {
    // Guardar el d√≠a y slot seleccionados
    setSelectedDay(day);
    setSelectedTimeSlot(slot);
    
    // Configurar el modal para desbloqueo
    setModalMode('unblock');
    setModalVisible(true);
    
    // Guardar el slot bloqueado si se proporciona
    setSelectedBlockedSlot(blockedSlot);
  };

  const executeUnblock = () => {
    // Verificar que tengamos los datos necesarios
    if (!selectedDay || !selectedTimeSlot) {
      Alert.alert('Error', 'Debes seleccionar un d√≠a y una hora');
      return;
    }
    
    // Llamar a la funci√≥n de desbloqueo con los valores seleccionados
    handleUnblockSlot(selectedDay.id, selectedTimeSlot.id, selectedBlockedSlot);
  };

  const handleBlockSlot = async () => {
    try {
      if (!selectedTimeSlot) {
        return;
      }
      
      setIsLoading(true);
      
      // Obtener el ID del manager
      const managerId = getValidManagerId();
      if (!managerId) {
        Alert.alert('Error', 'No se pudo identificar el manager');
        setIsLoading(false);
        return;
      }
      
      // Obtener el d√≠a y la hora seleccionados
      const dayId = selectedDay ? parseInt(selectedDay.id, 10) : null;
      const hourId = selectedTimeSlot ? parseInt(selectedTimeSlot.id, 10) : null;
      
      if (dayId === null || hourId === null) {
        Alert.alert('Error', 'D√≠a u hora no seleccionados');
        setIsLoading(false);
        return;
      }
      
      // Obtener la fecha correspondiente al d√≠a seleccionado
      let dateToUse = null;
      let dateStrToUse = null;
      
      // Si estamos usando una fecha espec√≠fica, usarla
      if (useSpecificDate && selectedDate) {
        try {
          dateToUse = selectedDate;
          // IMPORTANTE: Asegurar que la fecha se guarde correctamente sin desfase
          dateStrToUse = selectedDate.toISOString().split('T')[0];
          console.log(`Usando fecha espec√≠fica: ${dateStrToUse}`);
        } catch (error) {
          console.error('Error al procesar fecha espec√≠fica:', error);
          Alert.alert('Error', 'Formato de fecha incorrecto');
          setIsLoading(false);
          return;
        }
      } else {
        // Si no, usar la fecha correspondiente al d√≠a seleccionado
        const selectedDayWithDate = weekDaysWithDates.find(day => parseInt(day.id, 10) === dayId);
        if (selectedDayWithDate && selectedDayWithDate.date) {
          // IMPORTANTE: Usar directamente la fecha del d√≠a seleccionado sin modificaciones
          dateStrToUse = selectedDayWithDate.date;
          console.log(`Usando fecha del d√≠a seleccionado (sin modificar): ${dateStrToUse}`);
          
          try {
            // Crear objeto Date sin ajustes de zona horaria para evitar desfases
            const [year, month, day] = dateStrToUse.split('-').map(num => parseInt(num, 10));
            dateToUse = new Date(year, month - 1, day); // month es 0-indexed en JavaScript
            console.log(`Fecha creada: ${dateToUse.toISOString()}`);
          } catch (error) {
            console.error(`Error al crear objeto Date con ${dateStrToUse}:`, error);
            // Continuar con dateStrToUse aunque dateToUse sea null
          }
        } else {
          console.log(`No se encontr√≥ fecha para el d√≠a ${dayId}`);
          Alert.alert('Error', 'No se pudo determinar la fecha para el d√≠a seleccionado');
          setIsLoading(false);
          return;
        }
      }
      
      if (!dateStrToUse) {
        Alert.alert('Error', 'No se pudo determinar la fecha para bloquear el horario');
        setIsLoading(false);
        return;
      }
      
      // Crear el objeto de slot bloqueado
      const blockedSlot = {
        managerId,
        hour: hourId,
        day: dayId,
        dayName: getDayName(dayId),
        date: dateStrToUse,
        dateStr: dateStrToUse,
        isRecurring: isRecurring
      };
      
      console.log(`Bloqueando slot: d√≠a=${dayId}, hora=${hourId}, fecha=${dateStrToUse}`);
      
      // Enviar al backend - probar con URL alternativa
      const response = await axios.post(`${BACKEND_URL}/api/spaces/block-slot/${managerId}`, blockedSlot);
      
      if (response.status === 201 || response.status === 200) {
        console.log('Slot bloqueado exitosamente');
        
        // Actualizar el estado local
        const newBlockedSlot = response.data;
        
        // Asegurar que el slot tenga la fecha correcta
        const updatedSlot = {
          ...newBlockedSlot,
          date: dateStrToUse,
          dateStr: dateStrToUse,
          day: dayId,
          hour: hourId,
          dayName: getDayName(dayId)
        };
        
        // ACTUALIZACI√ìN INMEDIATA: A√±adir el nuevo slot al estado
        setBlockedSlots(prev => {
          const newSlots = [...prev, updatedSlot];
          console.log(`‚úÖ Slots bloqueados actualizados: ${newSlots.length} slots`);
          return newSlots;
        });
        
        // ACTUALIZACI√ìN INMEDIATA: Actualizar el mapa de slots bloqueados por fecha
        setBlockedSlotsByDate(prev => {
          const newMap = { ...prev };
          if (!newMap[dateStrToUse]) {
            newMap[dateStrToUse] = [];
          }
          
          // Verificar si ya existe un slot con la misma hora para evitar duplicados
          const slotExists = newMap[dateStrToUse].some(slot => {
            const slotHour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
            return slotHour === hourId;
          });
          
          if (!slotExists) {
            newMap[dateStrToUse].push(updatedSlot);
            console.log(`‚úÖ Slot a√±adido a fecha ${dateStrToUse}: hora=${hourId}`);
          }
          
          return newMap;
        });
        
        // ACTUALIZACI√ìN INMEDIATA: Forzar actualizaci√≥n de la UI
        setForceUpdate(prev => prev + 1);
        
        // Cerrar el modal
        setModalVisible(false);
        
        // Ocultar indicador de carga
        setIsLoading(false);
        
        // Mostrar mensaje de √©xito
        Alert.alert('√âxito', 'Horario bloqueado correctamente');
        
        // ACTUALIZACI√ìN INMEDIATA: Actualizar la visualizaci√≥n sin necesidad de recargar
        setTimeout(() => {
          // Forzar una segunda actualizaci√≥n despu√©s de un breve retraso
          // para asegurar que la UI se actualice correctamente
          setForceUpdate(prev => prev + 1);
        }, 100);
      } else {
        console.error('Error al bloquear slot:', response.data);
        Alert.alert('Error', 'No se pudo bloquear el horario');
        setIsLoading(false);
      }
    } catch (error) {
      console.error('Error al bloquear slot:', error);
      Alert.alert('Error', 'No se pudo bloquear el horario: ' + (error.message || 'Error desconocido'));
      setIsLoading(false);
    }
  };

  const handleSpecificDateChange = (date) => {
    if (!date) {
      console.log('Fecha espec√≠fica es null o undefined');
      return;
    }
    
    try {
      console.log(`Cambiando fecha espec√≠fica a: ${date.toLocaleDateString()}`);
      // Cerrar el selector de fecha
      setShowConfigDatePicker(false);
      // Actualizar la fecha espec√≠fica sin desencadenar una carga inmediata
      setConfigSpecificDate(date);
    } catch (error) {
      console.error('Error al formatear fecha:', error);
      // Cerrar el selector de fecha de todos modos
      setShowConfigDatePicker(false);
      // Actualizar la fecha espec√≠fica usando un formato alternativo
      setConfigSpecificDate(date);
    }
  };

  const openAvailabilityModal = (date = null) => {
    // Si se proporciona una fecha, configurarla
    if (date) {
      setConfigSpecificDate(date);
    }
    
    // Configurar el modo del modal
    setModalMode('availability');
    
    // Mostrar el modal
    setModalVisible(true);
  };

  const loadSpecificDateAvailability = (date) => {
    if (!date) return;
    
    // Evitar ciclos de carga
    if (isLoading) return;
    
    console.log(`Cargando disponibilidad para fecha espec√≠fica: ${date.toLocaleDateString()}`);
    
    // Primero cargar la configuraci√≥n general como base
    const managerId = getValidManagerId();
    if (!managerId) return;
    
    // Mostrar indicador de carga
    setIsLoading(true);
    
    // Cargar primero la configuraci√≥n general como base
    axios.get(`${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`)
      .then(generalResponse => {
        if (generalResponse.data && generalResponse.data.success) {
          // Guardar la configuraci√≥n general como base
          const generalSettings = generalResponse.data.availability;
          console.log('Configuraci√≥n general cargada como base:', generalSettings);
          
          // Ahora cargar la configuraci√≥n espec√≠fica
          const dateString = date.toISOString().split('T')[0];
          axios.get(`${BACKEND_URL}/api/cultural-spaces/availability/${managerId}?date=${dateString}`)
            .then(specificResponse => {
              setIsLoading(false);
              
              if (specificResponse.data && specificResponse.data.success) {
                const specificSettings = specificResponse.data.availability;
                
                // Si hay configuraci√≥n espec√≠fica, combinarla con la general
                if (Object.keys(specificSettings).length > 0) {
                  console.log('Configuraci√≥n espec√≠fica encontrada:', specificSettings);
                  
                  // Combinar configuraci√≥n general con espec√≠fica
                  const combinedSettings = { ...generalSettings };
                  
                  // Sobrescribir solo los d√≠as que tienen configuraci√≥n espec√≠fica
                  for (const day in specificSettings) {
                    combinedSettings[day] = specificSettings[day];
                  }
                  
                  setAvailabilitySettings(combinedSettings);
                  console.log('Configuraci√≥n combinada:', combinedSettings);
                } else if (specificResponse.data.canCreateConfig) {
                  // Si no hay configuraci√≥n espec√≠fica pero se puede crear, usar la general como base
                  setAvailabilitySettings(generalSettings);
                  console.log('No hay configuraci√≥n espec√≠fica, usando general como base');
                  
                  // Preguntar si quiere crear configuraci√≥n espec√≠fica
                  if (!isConfiguringSpecificDate && !modalVisible) {
                    Alert.alert(
                      'Configuraci√≥n no encontrada',
                      `No hay configuraci√≥n espec√≠fica para ${date.toLocaleDateString()}. ¬øDeseas crear una?`,
                      [
                        {
                          text: 'No',
                          style: 'cancel',
                          onPress: () => {
                            // Volver a cargar la configuraci√≥n general
                            setUseSpecificDate(false);
                            setConfigSpecificDate(null);
                            loadAvailabilitySettings();
                          }
                        },
                        {
                          text: 'S√≠, configurar',
                          onPress: () => {
                            // Configurar para fecha espec√≠fica
                            setUseSpecificDate(true);
                            setConfigSpecificDate(date);
                            
                            // Abrir el modal para configurar
                            setModalMode('availability');
                            setModalVisible(true);
                          }
                        }
                      ]
                    );
                  }
                  return;
                }
              } else {
                console.error('Error al cargar configuraci√≥n espec√≠fica:', specificResponse.data?.message);
                setAvailabilitySettings(generalSettings);
              }
            })
            .catch(error => {
              console.error('Error al cargar configuraci√≥n espec√≠fica:', error);
              setIsLoading(false);
              setAvailabilitySettings(generalSettings);
            });
        } else {
          console.error('Error al cargar configuraci√≥n general:', generalResponse.data?.message);
          setIsLoading(false);
        }
      })
      .catch(error => {
        console.error('Error al cargar configuraci√≥n general:', error);
        setIsLoading(false);
      });
  };

  const getCurrentWeekDates = () => {
    const today = new Date();
    const currentDay = today.getDay(); // 0 = domingo, 1 = lunes, ..., 6 = s√°bado
    const result = [];
    
    // Ajustar para que la semana comience en lunes (1)
    const firstDayOfWeek = 1; // Lunes
    
    // Calcular el lunes de la semana actual
    const mondayOffset = currentDay === 0 ? -6 : firstDayOfWeek - currentDay;
    const monday = new Date(today);
    monday.setDate(today.getDate() + mondayOffset);
    
    // Generar fechas para cada d√≠a de la semana (lunes a domingo)
    for (let i = 0; i < 7; i++) {
      const date = new Date(monday);
      date.setDate(monday.getDate() + i);
      result.push(date);
    }
    
    return result;
  };

  // Obtener fechas de la semana actual
  const weekDates = useMemo(() => getCurrentWeekDates(), []);

  // Calcular los d√≠as de la semana con sus fechas correspondientes
  // Pero NO actualizar el estado aqu√≠ para evitar ciclos infinitos
  const calculatedWeekDaysWithDates = useMemo(() => {
    return weekDays.map((day, index) => {
      const date = weekDates[index];
      const formattedDate = date.toISOString().split('T')[0]; // Formato YYYY-MM-DD
      const displayDate = `${date.getDate()}/${date.getMonth() + 1}`; // Formato DD/MM
      
      return {
        ...day,
        date: formattedDate,
        displayDate: displayDate
      };
    });
  }, [weekDays, weekDates]);
  
  // Inicializar weekDaysWithDates una sola vez al montar el componente
  useEffect(() => {
    // Solo actualizar si el estado est√° vac√≠o para evitar ciclos
    if (weekDaysWithDates.length === 0) {
      setWeekDaysWithDates(calculatedWeekDaysWithDates);
    }
  }, [calculatedWeekDaysWithDates, weekDaysWithDates.length]);

  const renderModal = () => {
    return (
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            {/* Se elimin√≥ el header del modal */}
            <TouchableOpacity
              style={[styles.closeButton, { position: 'absolute', top: 10, right: 10, zIndex: 10 }]}
              onPress={() => setModalVisible(false)}
            >
              <Ionicons name="close" size={24} color="#FFF" />
            </TouchableOpacity>
            <View style={styles.modalBody}>
              {(modalMode === 'block' || modalMode === 'unblock') && (
                <View>
                  {modalMode === 'block' && (
                    <View style={styles.datePickerContainer}>
                      <View style={styles.switchContainer}>
                        <Text style={styles.switchLabel}>Usar fecha espec√≠fica</Text>
                        <Switch
                          value={useSpecificDate}
                          onValueChange={(value) => {
                            if (value) {
                              setIsRecurring(false); // No puede ser recurrente si es fecha espec√≠fica
                            }
                            setUseSpecificDate(value);
                          }}
                          trackColor={{ false: '#ccc', true: '#4A90E2' }}
                          thumbColor={useSpecificDate ? '#FFFFFF' : '#f4f3f4'}
                        />
                      </View>
                      
                      {useSpecificDate && (
                        <View style={styles.datePickerWrapper}>
                          <TouchableOpacity
                            style={styles.datePickerButton}
                            onPress={() => setShowDatePicker(true)}
                          >
                            <Text style={styles.datePickerButtonText}>
                              Seleccionar fecha: {selectedDate.toLocaleDateString()}
                            </Text>
                            <Ionicons name="calendar" size={20} color="#FFF" />
                          </TouchableOpacity>
                          
                          {showDatePicker && (
                            <View>
                              {Platform.OS === 'ios' ? (
                                <DatePickerIOS
                                  date={selectedDate}
                                  onDateChange={setSelectedDate}
                                  mode="date"
                                  style={{ height: 200, marginTop: 10 }}
                                />
                              ) : (
                                <DateTimePicker
                                  value={selectedDate}
                                  mode="date"
                                  display="default"
                                  onChange={(event, date) => {
                                    setShowDatePicker(false);
                                    if (date) {
                                      setSelectedDate(date);
                                    }
                                  }}
                                />
                              )}
                              
                              {Platform.OS === 'ios' && (
                                <TouchableOpacity
                                  style={[styles.modalButton, { backgroundColor: '#4A90E2', marginTop: 10 }]}
                                  onPress={() => setShowDatePicker(false)}
                                >
                                  <Text style={styles.modalButtonText}>Confirmar fecha</Text>
                                </TouchableOpacity>
                              )}
                            </View>
                          )}
                        </View>
                      )}
                    </View>
                  )}
                  
                  <Text style={styles.modalLabel}>Selecciona una franja horaria:</Text>
                  <ScrollView style={{ maxHeight: 300 }}>
                    {timeSlots.map(slot => {
                      // Asegurarnos de que los IDs sean n√∫meros para comparaci√≥n consistente
                      const dayId = selectedDay ? parseInt(selectedDay.id, 10) : null;
                      const hourId = parseInt(slot.id, 10);
                      
                      // Obtener la fecha correspondiente al d√≠a seleccionado
                      const selectedDayWithDate = weekDaysWithDates.find(d => parseInt(d.id, 10) === dayId);
                      const currentDayDate = selectedDayWithDate?.date || null;
                      
                      // Verificar si estamos en modo de fecha espec√≠fica
                      const isSpecificDateMode = selectedDate !== null;
                      
                      // Determinar la fecha a verificar
                      const dateToCheck = isSpecificDateMode && selectedDate ? selectedDate.toISOString().split('T')[0] : currentDayDate;
                      
                      // Verificar disponibilidad
                      const isAvailable = availabilitySettings[dayId]?.includes(hourId);
                      
                      // SOLUCI√ìN DIRECTA: Verificar SOLO la fecha actual (no fechas adyacentes)
                      // Esto evita que los slots bloqueados aparezcan en m√∫ltiples d√≠as
                      let isBlockedSlot = false;
                      
                      // Verificar si el slot est√° bloqueado para esta fecha espec√≠fica
                      if (dateToCheck && blockedSlotsByDate && blockedSlotsByDate[dateToCheck]) {
                        const blockedSlotsForDate = blockedSlotsByDate[dateToCheck];
                        
                        isBlockedSlot = blockedSlotsForDate.some(blockedSlot => {
                          const blockedHour = typeof blockedSlot.hour === 'string' ? parseInt(blockedSlot.hour, 10) : blockedSlot.hour;
                          return blockedHour === hourId;
                        });
                        
                        if (isBlockedSlot) {
                          console.log(`‚úÖ Slot bloqueado encontrado en fecha ${dateToCheck}, hora=${hourId}`);
                        }
                      }
                      
                      // Solo mostrar para desbloquear si est√° bloqueado
                      if (modalMode === 'unblock' && !isBlockedSlot) return null;
                      
                      // Solo mostrar para bloquear si no est√° bloqueado
                      if (modalMode === 'block' && isBlockedSlot) return null;
                      
                      return (
                        <TouchableOpacity
                          key={`slot-${slot.id}`}
                          style={[
                            styles.timeSlotItem,
                            selectedTimeSlot?.id === slot.id && styles.selectedTimeSlotItem
                          ]}
                          onPress={() => setSelectedTimeSlot(slot)}
                        >
                          <Text style={styles.timeSlotText}>
                            {`${slot.hour}:00 ${slot.period}`}
                          </Text>
                          {selectedTimeSlot?.id === slot.id && (
                            <Ionicons name="checkmark" size={20} color="#4A90E2" />
                          )}
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  
                  {modalMode === 'block' && !useSpecificDate && (
                    <View style={styles.switchContainer}>
                      <Text style={styles.switchLabel}>¬øRepetir semanalmente?</Text>
                      <Switch
                        value={isRecurring}
                        onValueChange={setIsRecurring}
                        trackColor={{ false: '#ccc', true: '#4A90E2' }}
                        thumbColor={isRecurring ? '#FFFFFF' : '#f4f3f4'}
                      />
                    </View>
                  )}
                </View>
              )}
              
              {modalMode === 'info' && selectedTimeSlot && (
                <View style={styles.eventInfoContainer}>
                  {events.find(event => 
                    new Date(event.fecha).getDay() === selectedDay?.id && 
                    parseInt(event.horaInicio.split(':')[0]) === selectedTimeSlot?.id
                  ) ? (
                    <View>
                      <Text style={styles.eventTitle}>
                        {events.find(event => 
                          new Date(event.fecha).getDay() === selectedDay?.id && 
                          parseInt(event.horaInicio.split(':')[0]) === selectedTimeSlot?.id
                        )?.titulo || 'Evento'}
                      </Text>
                      <Text style={styles.eventDescription}>
                        {events.find(event => 
                          new Date(event.fecha).getDay() === selectedDay?.id && 
                          parseInt(event.horaInicio.split(':')[0]) === selectedTimeSlot?.id
                        )?.descripcion || 'Sin descripci√≥n'}
                      </Text>
                    </View>
                  ) : (
                    <Text style={styles.noEventText}>No hay eventos en esta franja horaria</Text>
                  )}
                </View>
              )}
              
              {modalMode === 'availability' && (
                <View style={styles.availabilityContainer}>
                  <View style={styles.switchContainer}>
                    <Text style={styles.switchLabel}>Configurar para fecha espec√≠fica</Text>
                    <Switch
                      value={!!configSpecificDate}
                      onValueChange={(value) => {
                        if (value) {
                          setConfigSpecificDate(new Date());
                          setShowConfigDatePicker(true);
                        } else {
                          setConfigSpecificDate(null);
                          // Recargar la configuraci√≥n general
                          loadAvailabilitySettings();
                        }
                      }}
                      trackColor={{ false: '#ccc', true: '#4A90E2' }}
                      thumbColor={configSpecificDate ? '#FFFFFF' : '#f4f3f4'}
                    />
                  </View>
                  
                  {configSpecificDate && (
                    <View style={styles.datePickerWrapper}>
                      <TouchableOpacity
                        style={styles.datePickerButton}
                        onPress={() => setShowConfigDatePicker(true)}
                      >
                        <Text style={styles.datePickerButtonText}>
                          Configurar para: {configSpecificDate.toLocaleDateString()}
                        </Text>
                        <Ionicons name="calendar" size={20} color="#FFF" />
                      </TouchableOpacity>
                      
                      {showConfigDatePicker && (
                        <View>
                          {Platform.OS === 'ios' ? (
                            <DatePickerIOS
                              date={configSpecificDate}
                              onDateChange={setConfigSpecificDate}
                              mode="date"
                              style={{ height: 200, marginTop: 10 }}
                            />
                          ) : (
                            <DateTimePicker
                              value={configSpecificDate}
                              mode="date"
                              display="default"
                              onChange={(event, date) => {
                                setShowConfigDatePicker(false);
                                if (date) {
                                  setConfigSpecificDate(date);
                                }
                              }}
                            />
                          )}
                          
                          {Platform.OS === 'ios' && (
                            <TouchableOpacity
                              style={[styles.modalButton, { backgroundColor: '#4A90E2', marginTop: 10 }]}
                              onPress={() => setShowConfigDatePicker(false)}
                            >
                              <Text style={styles.modalButtonText}>Confirmar fecha</Text>
                            </TouchableOpacity>
                          )}
                        </View>
                      )}
                    </View>
                  )}
                  
                  <Text style={styles.availabilityText}>
                    Configure los horarios disponibles para {configSpecificDate ? 'esta fecha' : 'este d√≠a'}:
                  </Text>
                  <ScrollView style={{ maxHeight: 350 }}>
                    {timeSlots.map(slot => (
                      <TouchableOpacity
                        key={`avail-${slot.id}`}
                        style={[
                          styles.availabilityItem,
                          availabilitySettings[selectedDay?.id]?.includes(slot.id) ? 
                            styles.availableItem : styles.unavailableItem
                        ]}
                        onPress={() => updateAvailability(
                          selectedDay, 
                          slot, 
                          !availabilitySettings[selectedDay?.id]?.includes(slot.id)
                        )}
                      >
                        <Text style={styles.availabilityItemText}>
                          {`${slot.hour}:00 ${slot.period}`}
                        </Text>
                        <Ionicons 
                          name={availabilitySettings[selectedDay?.id]?.includes(slot.id) ? 
                            "checkmark-circle" : "close-circle"} 
                          size={24} 
                          color={availabilitySettings[selectedDay?.id]?.includes(slot.id) ? 
                            "#4CAF50" : "#FF5252"} 
                        />
                      </TouchableOpacity>
                    ))}
                    <View style={{ height: 80 }} />
                  </ScrollView>
                </View>
              )}
            </View>
            
            <View style={styles.modalFooter}>
              {modalMode === 'block' && (
                <TouchableOpacity 
                  style={[styles.modalButton, styles.blockButton]}
                  onPress={handleBlockSlot}
                >
                  <Text style={styles.modalButtonText}>Bloquear Horario</Text>
                </TouchableOpacity>
              )}
              
              {modalMode === 'unblock' && (
                <TouchableOpacity 
                  style={[styles.modalButton, styles.unblockButton]}
                  onPress={executeUnblock}
                >
                  <Text style={styles.modalButtonText}>Desbloquear Horario</Text>
                </TouchableOpacity>
              )}
              
              {modalMode === 'availability' && (
                <TouchableOpacity 
                  style={[styles.modalButton, { backgroundColor: '#FF3A5E' }]}
                  onPress={handleUpdateAvailability}
                >
                  <Text style={styles.modalButtonText}>
                    {configSpecificDate ? 'Guardar para fecha espec√≠fica' : 'Guardar configuraci√≥n'}
                  </Text>
                </TouchableOpacity>
              )}
              
              <TouchableOpacity 
                style={[styles.modalButton, { backgroundColor: '#333' }]}
                onPress={() => setModalVisible(false)}
              >
                <Text style={styles.modalButtonText}>Cancelar</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  const initializeDefaultAvailability = () => {
    // Inicializar la disponibilidad con valores predeterminados (todos los d√≠as, todas las horas disponibles)
    const defaultSettings = {};
    weekDays.forEach(day => {
      defaultSettings[day.id] = timeSlots.map(slot => slot.id);
    });
    setAvailabilitySettings(defaultSettings);
  };

  // Funci√≥n para inicializar los d√≠as de la semana
  const initializeWeekDays = () => {
    // Obtener la fecha actual local sin componentes de tiempo
    const now = new Date();
    
    // Crear una fecha usando componentes locales para evitar problemas de zona horaria
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    // Formatear la fecha para depuraci√≥n
    const localDateStr = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;
    
    // Mostrar informaci√≥n detallada para depuraci√≥n
    console.log('üïí FECHA ACTUAL LOCAL:');
    console.log(`Fecha local: ${localDateStr}`);
    console.log(`D√≠a: ${today.getDate()}, Mes: ${today.getMonth() + 1}, A√±o: ${today.getFullYear()}`);
    console.log(`Zona horaria: GMT${-now.getTimezoneOffset() / 60}`);
    
    // Obtener el d√≠a de la semana actual (0 = domingo, 1 = lunes, ..., 6 = s√°bado)
    const currentDayOfWeek = today.getDay();
    console.log(`D√≠a de la semana actual: ${currentDayOfWeek} (${getDayName(currentDayOfWeek)})`);
    
    // Crear array con los 7 d√≠as de la semana
    const days = [];
    
    // Calcular el inicio de la semana (lunes)
    const mondayOffset = currentDayOfWeek === 0 ? -6 : -(currentDayOfWeek - 1);
    const monday = new Date(today);
    monday.setDate(today.getDate() + mondayOffset);
    
    const mondayStr = `${monday.getFullYear()}-${(monday.getMonth() + 1).toString().padStart(2, '0')}-${monday.getDate().toString().padStart(2, '0')}`;
    console.log(`Lunes de esta semana: ${mondayStr}`);
    
    // Generar los d√≠as de la semana con sus fechas correspondientes
    for (let i = 0; i < 7; i++) {
      // Crear una nueva fecha para cada d√≠a
      const date = new Date(monday);
      date.setDate(monday.getDate() + i);
      
      // Formatear la fecha como YYYY-MM-DD (mismo formato que en la base de datos)
      const formattedYear = date.getFullYear();
      const formattedMonth = (date.getMonth() + 1).toString().padStart(2, '0');
      const formattedDay = date.getDate().toString().padStart(2, '0');
      const formattedDate = `${formattedYear}-${formattedMonth}-${formattedDay}`;
      
      // El ID del d√≠a es el √≠ndice del d√≠a en la semana (0=domingo, 1=lunes, ..., 6=s√°bado)
      const dayId = date.getDay();
      
      const dayObj = {
        id: dayId,
        name: getDayName(dayId),
        shortName: getDayName(dayId).substring(0, 3),
        date: formattedDate,
        dateObj: date,
        displayDate: `${formattedDay}/${formattedMonth}` // Formato DD/MM
      };
      
      days.push(dayObj);
      console.log(`D√≠a ${i+1}: id=${dayObj.id}, nombre=${dayObj.name}, fecha=${dayObj.date}`);
    }
    
    return days;
  };

  // Funci√≥n para depurar las fechas de los d√≠as de la semana
  const debugWeekDays = () => {
    console.log('üîç DEPURACI√ìN DE D√çAS DE LA SEMANA:');
    
    // Obtener la fecha actual LOCAL (sin conversi√≥n a UTC)
    const now = new Date();
    const localDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    const formattedDate = `${localDate.getFullYear()}-${(localDate.getMonth() + 1).toString().padStart(2, '0')}-${localDate.getDate().toString().padStart(2, '0')}`;
    
    console.log('Fecha actual LOCAL:', formattedDate);
    console.log('D√≠a de la semana:', getDayName(localDate.getDay()));
    
    weekDaysWithDates.forEach((day, index) => {
      console.log(`D√≠a ${index + 1}: id=${day.id}, nombre=${day.name}, fecha=${day.date}`);
      
      // Verificar si hay slots bloqueados para esta fecha
      if (day.date && blockedSlotsByDate[day.date]) {
        console.log(`  ‚úÖ Slots bloqueados para ${day.date}: ${blockedSlotsByDate[day.date].length}`);
        blockedSlotsByDate[day.date].forEach((slot, index) => {
          console.log(`    üìå Slot ${index + 1}: hora=${slot.hour}, d√≠a=${slot.day}, id=${slot.id}`);
        });
      } else {
        console.log(`  ‚ùå No hay slots bloqueados para ${day.date}`);
      }
    });
    
    // Verificar todas las fechas con slots bloqueados
    console.log('üìÖ Todas las fechas con slots bloqueados:');
    Object.keys(blockedSlotsByDate).forEach(dateKey => {
      console.log(`  üìÜ Fecha: ${dateKey}, Slots: ${blockedSlotsByDate[dateKey].length}`);
      
      // Verificar si esta fecha corresponde a alg√∫n d√≠a de la semana
      const dayWithThisDate = weekDaysWithDates.find(day => day.date === dateKey);
      if (dayWithThisDate) {
        console.log(`    ‚úÖ Corresponde al d√≠a: ${dayWithThisDate.name} (${dayWithThisDate.id})`);
      } else {
        console.log(`    ‚ùå No corresponde a ning√∫n d√≠a de esta semana`);
      }
    });
  };

  // Funci√≥n para depurar profundamente el problema de fechas
  const debugDateIssue = () => {
    // Obtener la fecha actual LOCAL (sin conversi√≥n a UTC)
    const now = new Date();
    const localDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    // Formatear la fecha en el formato deseado
    const formattedDate = `${localDate.getFullYear()}-${(localDate.getMonth() + 1).toString().padStart(2, '0')}-${localDate.getDate().toString().padStart(2, '0')}`;
    
    // Mostrar solo la informaci√≥n esencial en formato limpio
    Alert.alert(
      'Depuraci√≥n de Fechas',
      `Fecha actual:\n${formattedDate}\n` +
      `D√≠a: ${localDate.getDate()}, Mes: ${localDate.getMonth() + 1}, A√±o: ${localDate.getFullYear()}\n` +
      `D√≠a de la semana: ${getDayName(localDate.getDay())}\n\n` +
      `Slots bloqueados:\n` +
      (blockedSlotsByDate && Object.keys(blockedSlotsByDate).length > 0 
        ? Object.keys(blockedSlotsByDate).map(dateKey => 
            `Fecha ${dateKey}: ${blockedSlotsByDate[dateKey].length} slots`
          ).join('\n')
        : 'No hay slots bloqueados registrados'),
      [
        { 
          text: 'OK' 
        }
      ]
    );
  };
  
  // Funci√≥n para mostrar m√°s detalles de depuraci√≥n
  const showMoreDebugInfo = () => {
    // Obtener la fecha actual LOCAL (sin conversi√≥n a UTC)
    const now = new Date();
    const localDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    // Formatear la fecha para mostrar
    const formattedDate = `${localDate.getFullYear()}-${(localDate.getMonth() + 1).toString().padStart(2, '0')}-${localDate.getDate().toString().padStart(2, '0')}`;
    
    // Recopilar informaci√≥n detallada sobre los slots bloqueados
    let detailedInfo = '';
    
    // Mostrar informaci√≥n de la fecha actual
    detailedInfo += `Fecha actual: ${formattedDate}\n`;
    detailedInfo += `D√≠a de la semana: ${getDayName(localDate.getDay())}\n\n`;
    
    if (!blockedSlotsByDate || Object.keys(blockedSlotsByDate).length === 0) {
      detailedInfo = 'No hay slots bloqueados para analizar';
    } else {
      Object.keys(blockedSlotsByDate).forEach(dateKey => {
        detailedInfo += `\nFecha: ${dateKey}\n`;
        
        // Verificar si esta fecha corresponde a alg√∫n d√≠a de la semana
        const dayWithThisDate = weekDaysWithDates.find(day => day.date === dateKey);
        if (dayWithThisDate) {
          detailedInfo += `Corresponde a: ${dayWithThisDate.name}\n`;
        } else {
          detailedInfo += 'No corresponde a ning√∫n d√≠a de esta semana\n';
        }
        
        // Mostrar detalles de los slots
        blockedSlotsByDate[dateKey].forEach((slot, index) => {
          detailedInfo += `  Slot ${index + 1}: hora=${slot.hour}, d√≠a=${slot.day}\n`;
        });
      });
    }
    
    // Mostrar la informaci√≥n detallada en una alerta
    Alert.alert(
      'Detalles de Slots Bloqueados',
      detailedInfo,
      [
        { 
          text: 'Limpiar Slots Duplicados', 
          onPress: () => cleanupDuplicateSlots() 
        },
        { 
          text: 'OK' 
        }
      ]
    );
  };

  // Funci√≥n para limpiar slots duplicados
  const cleanupDuplicateSlots = () => {
    if (!blockedSlotsByDate || Object.keys(blockedSlotsByDate).length === 0) {
      Alert.alert('Info', 'No hay slots bloqueados para limpiar');
      return;
    }
    
    // Crear un mapa para rastrear slots √∫nicos por hora
    const uniqueSlotsByHour = new Map();
    let duplicatesRemoved = 0;
    
    // Recorrer todas las fechas y sus slots
    Object.keys(blockedSlotsByDate).forEach(dateKey => {
      const slots = blockedSlotsByDate[dateKey];
      
      // Filtrar slots duplicados
      const uniqueSlots = slots.filter(slot => {
        const hour = typeof slot.hour === 'string' ? parseInt(slot.hour, 10) : slot.hour;
        const key = `${hour}`;
        
        if (uniqueSlotsByHour.has(key)) {
          duplicatesRemoved++;
          return false;
        } else {
          uniqueSlotsByHour.set(key, slot);
          return true;
        }
      });
      
      // Actualizar el mapa con los slots √∫nicos
      blockedSlotsByDate[dateKey] = uniqueSlots;
    });
    
    // Actualizar el estado
    setBlockedSlotsByDate({...blockedSlotsByDate});
    
    // Notificar al usuario
    Alert.alert('Limpieza Completada', `Se eliminaron ${duplicatesRemoved} slots duplicados`);
    
    // Forzar actualizaci√≥n de la UI
    setForceUpdate(prev => prev + 1);
  };

  // Funci√≥n para forzar la actualizaci√≥n de fechas y slots bloqueados
  const forceUpdateDates = () => {
    console.log('üîÑ Forzando actualizaci√≥n de fechas y slots bloqueados...');
    
    // Mostrar indicador de carga
    setLoading(true);
    
    // Inicializar los d√≠as de la semana con fechas actualizadas
    const updatedWeekDays = initializeWeekDays();
    setWeekDaysWithDates(updatedWeekDays);
    
    // Seleccionar el d√≠a actual
    const now = new Date();
    const todayDayOfWeek = now.getDay(); // 0 = domingo, 1 = lunes, ..., 6 = s√°bado
    const todayDay = updatedWeekDays.find(day => parseInt(day.id, 10) === todayDayOfWeek);
    
    if (todayDay) {
      setSelectedDay(todayDay);
      console.log(`D√≠a seleccionado actualizado: ${todayDay.name} (${todayDay.date})`);
      
      // Tambi√©n actualizar la fecha seleccionada
      const [year, month, day] = todayDay.date.split('-').map(num => parseInt(num, 10));
      const dateObj = new Date(year, month - 1, day);
      setSelectedDate(dateObj);
    }
    
    // Recargar los slots bloqueados para asegurar que est√©n correctamente asignados
    loadBlockedSlots().then(() => {
      console.log('‚úÖ Slots bloqueados actualizados correctamente');
      
      // Ejecutar depuraci√≥n para verificar
      debugWeekDays();
      debugBlockedSlots();
      
      // Ocultar indicador de carga
      setLoading(false);
      
      // Forzar actualizaci√≥n de la UI
      setForceUpdate(prev => prev + 1);
      
      // Mostrar mensaje de √©xito
      Alert.alert(
        'Actualizaci√≥n Completada',
        'Las fechas y slots bloqueados han sido actualizados correctamente.',
        [{ text: 'OK' }]
      );
    }).catch(error => {
      console.error('Error al actualizar slots bloqueados:', error);
      setLoading(false);
      
      Alert.alert(
        'Error',
        'Ocurri√≥ un error al actualizar los slots bloqueados. Por favor, int√©ntalo de nuevo.',
        [{ text: 'OK' }]
      );
    });
  };

  // Funci√≥n para verificar la fecha actual
  const checkCurrentDate = () => {
    const now = new Date();
    const localDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    const formattedDate = `${localDate.getFullYear()}-${(localDate.getMonth() + 1).toString().padStart(2, '0')}-${localDate.getDate().toString().padStart(2, '0')}`;
    
    Alert.alert(
      'Fecha Actual',
      `Fecha de hoy: ${formattedDate}\n` +
      `D√≠a: ${localDate.getDate()}, Mes: ${localDate.getMonth() + 1}, A√±o: ${localDate.getFullYear()}\n` +
      `D√≠a de la semana: ${getDayName(localDate.getDay())}\n` +
      `Fecha en formato DD/MM/AAAA: ${localDate.getDate().toString().padStart(2, '0')}/${(localDate.getMonth() + 1).toString().padStart(2, '0')}/${localDate.getFullYear()}`
    );
  };

  const handleUpdateAvailability = async () => {
    try {
      setIsLoading(true);
      
      // Obtener el ID del manager
      const managerId = getValidManagerId();
      if (!managerId) {
        Alert.alert('Error', 'No se pudo identificar el manager');
        setIsLoading(false);
        return;
      }
      
      // Preparar datos para enviar al backend
      const requestData = {
        availability: availabilitySettings
      };
      
      // Si estamos configurando para una fecha espec√≠fica, incluirla
      if (configSpecificDate) {
        requestData.date = configSpecificDate.toISOString().split('T')[0];
        console.log(`Guardando configuraci√≥n para fecha espec√≠fica: ${requestData.date}`);
      } else {
        console.log('Guardando configuraci√≥n general (sin fecha espec√≠fica)');
      }
      
      // Construir la URL
      const url = `${BACKEND_URL}/api/cultural-spaces/availability/${managerId}`;
      
      // Enviar la configuraci√≥n al backend
      console.log('Enviando datos al servidor:', JSON.stringify(requestData));
      const response = await axios.post(url, requestData);
      
      setIsLoading(false);
      
      if (response.data && response.data.success) {
        console.log('Configuraci√≥n guardada exitosamente');
        
        // Guardar localmente para acceso r√°pido
        saveAvailabilityToStorage(availabilitySettings);
        
        // Cerrar el modal
        setModalVisible(false);
        
        // Mostrar mensaje de √©xito
        Alert.alert('√âxito', 'Configuraci√≥n guardada correctamente');
        
        // Forzar actualizaci√≥n de la UI
        setForceUpdate(prev => prev + 1);
      } else {
        console.error('Error al guardar configuraci√≥n:', response.data);
        Alert.alert('Error', 'No se pudo guardar la configuraci√≥n');
      }
    } catch (error) {
      console.error('Error al guardar configuraci√≥n:', error);
      Alert.alert('Error', 'No se pudo guardar la configuraci√≥n: ' + (error.message || 'Error desconocido'));
      setIsLoading(false);
    }
  };

 

  return (
    <View style={styles.container}>
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#FF3A5E" />
          <Text style={styles.loadingText}>Cargando informaci√≥n...</Text>
        </View>
      ) : (
        <>
          <View style={styles.header}>
            <TouchableOpacity 
              onPress={() => {
                if (onClose && typeof onClose === 'function') {
                  onClose();
                } else {
                  navigation.goBack();
                }
              }} 
              style={styles.backButton}
            >
              <Ionicons name="arrow-back" size={24} color="#FFF" />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>{spaceData?.nombre || 'Gesti√≥n de Horarios'}</Text>
            <View style={styles.headerRight}>
              {/* Los iconos han sido eliminados pero la funcionalidad se mantiene */}
            </View>
          </View>
          <ScrollView style={styles.scrollContainer} contentContainerStyle={styles.scrollContentContainer}>
            <View style={styles.contentContainer}>
              <View style={styles.weekDaysContainer}>
                {weekDaysWithDates.map(day => (
                  <TouchableOpacity
                    key={day.id}
                    style={[
                      styles.dayButton,
                      selectedDay?.id === day.id && styles.selectedDayButton
                    ]}
                    onPress={() => handleDayPress(day)}
                  >
                    <Text style={[
                      styles.dayText,
                      selectedDay?.id === day.id && styles.selectedDayText
                    ]}>
                      {day.shortName}
                    </Text>
                    <Text style={styles.dayDate}>{day.name}</Text>
                    <Text style={styles.dayDate}>{day.displayDate}</Text>
                  </TouchableOpacity>
                ))}
              </View>
              
              {selectedDay && (
                <View style={styles.scheduleContainer}>
                  <View style={styles.scheduleHeader}>
                    <Text style={styles.scheduleDayTitle}>{selectedDay.name}</Text>
                    <View style={styles.scheduleActions}>
                      <TouchableOpacity
                        style={[styles.actionButton, { backgroundColor: '#FF3A5E' }]}
                        onPress={() => {
                          setModalMode('availability');
                          setModalVisible(true);
                        }}
                      >
                        <Ionicons name="time" size={18} color="#FFFFFF" />
                        <Text style={styles.actionButtonText}>Configurar</Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.actionButton, { backgroundColor: '#333' }]}
                        onPress={() => {
                          setModalMode('block');
                          setModalVisible(true);
                        }}
                      >
                        <Ionicons name="lock-closed" size={18} color="#FFFFFF" />
                        <Text style={styles.actionButtonText}>Bloquear</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                  
                  {/* Lista de horarios disponibles */}
                  {renderTimeSlots()}
                </View>
              )}
            </View>
          </ScrollView>
        </>
      )}
      
      {renderModal()}
      <View style={styles.buttonContainer}>
        <TouchableOpacity 
          style={[styles.button, { backgroundColor: '#FF3A5E' }]}
          onPress={handleResetBlockedSlots}
        >
          <Text style={styles.buttonText}>Restablecer Disponibilidad</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 15,
    paddingVertical: 15,
    backgroundColor: '#FF3A5E',
    marginTop: 35,         // Margen superior para respetar la barra de estado
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
    flex: 1,
  },
  closeButton: {
    padding: 5,
  },
  scrollContainer: {
    flex: 1,
  },
  scrollContentContainer: {
    paddingVertical: 20,
  },
  contentContainer: {
    padding: 15,
  },
  weekDaysContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  dayButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#333333',
    justifyContent: 'center',
    alignItems: 'center',
  },
  selectedDayButton: {
    backgroundColor: '#FF3A5E',
  },
  dayText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  selectedDayText: {
    color: '#FFFFFF',
  },
  dayDate: {
    fontSize: 12,
    color: '#FFFFFF',
    textAlign: 'center',
    marginTop: 5,
  },
  scheduleContainer: {
    marginBottom: 20,
  },
  scheduleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  scheduleDayTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  scheduleActions: {
    flexDirection: 'row',
  },
  actionButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 5,
    marginLeft: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButtonText: {
    color: '#FFFFFF',
    marginLeft: 5,
    fontSize: 14,
  },
  timeSlot: {
    padding: 12,
    borderRadius: 8,
    marginBottom: 10,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  availableSlot: {
    backgroundColor: '#1E3A2E',
  },
  unavailableSlot: {
    backgroundColor: '#3A1E1E',
  },
  eventSlot: {
    backgroundColor: '#1E2A3A',
  },
  timeText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  eventText: {
    color: '#4A90E2',
    fontSize: 14,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'right',
    marginRight: 10,
  },
  lockIcon: {
    marginLeft: 5,
  },
  // Estilos para el modal
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    maxHeight: '85%',
    backgroundColor: '#222222',
    borderRadius: 12,
    overflow: 'hidden',
  },
  modalBody: {
    padding: 15,
  },
  modalLabel: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 15,
  },
  timeSlotItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    backgroundColor: '#333333',
  },
  selectedTimeSlotItem: {
    backgroundColor: '#1E3A3A',
    borderWidth: 1,
    borderColor: '#4A90E2',
  },
  timeSlotText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 20,
    marginBottom: 10,
    paddingVertical: 10,
    paddingHorizontal: 10,
    backgroundColor: '#333333',
    borderRadius: 8,
  },
  switchLabel: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  availabilityContainer: {
    marginBottom: 10,
  },
  availabilityText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 15,
  },
  availabilityItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    backgroundColor: '#333333',
  },
  availableItem: {
    backgroundColor: '#1E3A2E',
  },
  unavailableItem: {
    backgroundColor: '#3A1E1E',
  },
  availabilityItemText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  eventInfoContainer: {
    padding: 10,
    backgroundColor: '#1E2A3A',
    borderRadius: 8,
  },
  eventTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  eventDescription: {
    fontSize: 16,
    color: '#CCCCCC',
  },
  noEventText: {
    fontSize: 16,
    color: '#CCCCCC',
    fontStyle: 'italic',
  },
  modalFooter: {
    padding: 15,
    borderTopWidth: 1,
    borderTopColor: '#444444',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  modalButton: {
    flex: 1,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 5,
  },
  blockButton: {
    backgroundColor: '#8C2626',
  },
  unblockButton: {
    backgroundColor: '#267F8C',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#FFFFFF',
    marginTop: 10,
    fontSize: 16,
  },
  buttonContainer: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    right: 20,
  },
  button: {
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  // Estilos adicionales para el selector de fechas
  datePickerContainer: {
    marginBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#444',
    paddingBottom: 15,
  },
  datePickerWrapper: {
    marginTop: 10,
  },
  datePickerButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#333',
    padding: 12,
    borderRadius: 8,
  },
  datePickerButtonText: {
    color: '#FFF',
    fontSize: 16,
  },
  blockedSlot: {
    backgroundColor: '#990000', // Rojo m√°s oscuro
    borderColor: '#990000'
  },
  blockedText: {
    color: '#FFFFFF',
  }
});

export default SpaceSchedule;
